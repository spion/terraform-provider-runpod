// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_pod

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PodResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"adjusted_cost_per_hr": schema.NumberAttribute{
				Computed:            true,
				Description:         "The effective cost in RunPod credits per hour of running a Pod, adjusted by active Savings Plans.",
				MarkdownDescription: "The effective cost in RunPod credits per hour of running a Pod, adjusted by active Savings Plans.",
			},
			"ai_api_id": schema.StringAttribute{
				Computed:            true,
				Description:         "Synonym for endpointId (legacy name).",
				MarkdownDescription: "Synonym for endpointId (legacy name).",
			},
			"allowed_cuda_versions": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, a list of acceptable CUDA versions on the [Pod](#/components/schemas/Pod). If not set, any CUDA version is acceptable.",
				MarkdownDescription: "If the created Pod is a GPU Pod, a list of acceptable CUDA versions on the [Pod](#/components/schemas/Pod). If not set, any CUDA version is acceptable.",
			},
			"cloud_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to SECURE to create the Pod in Secure Cloud. Set to COMMUNITY to create the Pod in Community Cloud. To determine which one suits your needs, see https://docs.runpod.io/references/faq/#secure-cloud-vs-community-cloud.",
				MarkdownDescription: "Set to SECURE to create the Pod in Secure Cloud. Set to COMMUNITY to create the Pod in Community Cloud. To determine which one suits your needs, see https://docs.runpod.io/references/faq/#secure-cloud-vs-community-cloud.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"SECURE",
						"COMMUNITY",
					),
				},
				Default: stringdefault.StaticString("SECURE"),
			},
			"compute_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to GPU to create a GPU Pod. Set to CPU to create a CPU Pod. If set to CPU, the Pod will not have a GPU attached and properties related to GPUs such as gpuTypeIds will be ignored. If set to GPU, the Pod will have a GPU attached and properties related to CPUs such as cpuFlavorIds will be ignored.",
				MarkdownDescription: "Set to GPU to create a GPU Pod. Set to CPU to create a CPU Pod. If set to CPU, the Pod will not have a GPU attached and properties related to GPUs such as gpuTypeIds will be ignored. If set to GPU, the Pod will have a GPU attached and properties related to CPUs such as cpuFlavorIds will be ignored.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"GPU",
						"CPU",
					),
				},
				Default: stringdefault.StaticString("GPU"),
			},
			"consumer_user_id": schema.StringAttribute{
				Computed:            true,
				Description:         "A unique string identifying the RunPod user who rents a Pod.",
				MarkdownDescription: "A unique string identifying the RunPod user who rents a Pod.",
			},
			"container_disk_in_gb": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The amount of disk space, in gigabytes (GB), to allocate on the container disk for the created Pod. The data on the container disk is wiped when the Pod restarts. To persist data across Pod restarts, set volumeInGb to configure the Pod network volume.",
				MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the container disk for the created Pod. The data on the container disk is wiped when the Pod restarts. To persist data across Pod restarts, set volumeInGb to configure the Pod network volume.",
				Default:             int64default.StaticInt64(50),
			},
			"container_registry_auth_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Registry credentials ID.",
				MarkdownDescription: "Registry credentials ID.",
			},
			"cost_per_hr": schema.NumberAttribute{
				Computed:            true,
				Description:         "The cost in RunPod credits per hour of running a Pod. Note that the actual cost may be lower if Savings Plans are applied.",
				MarkdownDescription: "The cost in RunPod credits per hour of running a Pod. Note that the actual cost may be lower if Savings Plans are applied.",
			},
			"country_codes": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "A list of country codes where the created Pod can be located. If not set, the Pod can be located in any country.",
				MarkdownDescription: "A list of country codes where the created Pod can be located. If not set, the Pod can be located in any country.",
			},
			"cpu_flavor_id": schema.StringAttribute{
				Computed:            true,
				Description:         "If the Pod is a CPU Pod, the unique string identifying the CPU flavor the Pod is running on.",
				MarkdownDescription: "If the Pod is a CPU Pod, the unique string identifying the CPU flavor the Pod is running on.",
			},
			"cpu_flavor_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a CPU Pod, a list of RunPod CPU flavors which can be attached to the Pod. The order of the list determines the order to rent CPU flavors. See cpuFlavorPriority for how the order of the list affects Pod creation.",
				MarkdownDescription: "If the created Pod is a CPU Pod, a list of RunPod CPU flavors which can be attached to the Pod. The order of the list determines the order to rent CPU flavors. See cpuFlavorPriority for how the order of the list affects Pod creation.",
			},
			"cpu_flavor_priority": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a CPU Pod, set to availability to respond to current CPU flavor availability. Set to custom to always try to rent CPU flavors in the order specified in cpuFlavorIds.",
				MarkdownDescription: "If the created Pod is a CPU Pod, set to availability to respond to current CPU flavor availability. Set to custom to always try to rent CPU flavors in the order specified in cpuFlavorIds.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"availability",
						"custom",
					),
				},
				Default: stringdefault.StaticString("availability"),
			},
			"data_center_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "A list of RunPod data center IDs where the created Pod can be located. See `dataCenterPriority` for information on how the order of the list affects Pod creation.",
				MarkdownDescription: "A list of RunPod data center IDs where the created Pod can be located. See `dataCenterPriority` for information on how the order of the list affects Pod creation.",
			},
			"data_center_priority": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to availability to respond to current machine availability. Set to custom to always try to rent machines from data centers in the order specified in dataCenterIds.",
				MarkdownDescription: "Set to availability to respond to current machine availability. Set to custom to always try to rent machines from data centers in the order specified in dataCenterIds.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"availability",
						"custom",
					),
				},
				Default: stringdefault.StaticString("availability"),
			},
			"desired_status": schema.StringAttribute{
				Computed:            true,
				Description:         "The current expected status of a Pod.",
				MarkdownDescription: "The current expected status of a Pod.",
			},
			"docker_entrypoint": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If specified, overrides the ENTRYPOINT for the Docker image run on the created Pod. If [], uses the ENTRYPOINT defined in the image.",
				MarkdownDescription: "If specified, overrides the ENTRYPOINT for the Docker image run on the created Pod. If [], uses the ENTRYPOINT defined in the image.",
			},
			"docker_start_cmd": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If specified, overrides the start CMD for the Docker image run on the created Pod. If [], uses the start CMD defined in the image.",
				MarkdownDescription: "If specified, overrides the start CMD for the Docker image run on the created Pod. If [], uses the start CMD defined in the image.",
			},
			"endpoint_id": schema.StringAttribute{
				Computed:            true,
				Description:         "If the Pod is a Serverless worker, a unique string identifying the associated endpoint.",
				MarkdownDescription: "If the Pod is a Serverless worker, a unique string identifying the associated endpoint.",
			},
			"env": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: EnvType{
					ObjectType: types.ObjectType{
						AttrTypes: EnvValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"global_networking": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true to enable global networking for the created Pod. Currently only available for On-Demand GPU Pods on some Secure Cloud data centers.",
				MarkdownDescription: "Set to true to enable global networking for the created Pod. Currently only available for On-Demand GPU Pods on some Secure Cloud data centers.",
				Default:             booldefault.StaticBool(false),
			},
			"gpu": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"community_price": schema.NumberAttribute{
						Computed: true,
					},
					"community_spot_price": schema.NumberAttribute{
						Computed: true,
					},
					"count": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of GPUs attached to a Pod.",
						MarkdownDescription: "The number of GPUs attached to a Pod.",
					},
					"display_name": schema.StringAttribute{
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed: true,
					},
					"one_month_price": schema.NumberAttribute{
						Computed: true,
					},
					"one_week_price": schema.NumberAttribute{
						Computed: true,
					},
					"secure_price": schema.NumberAttribute{
						Computed: true,
					},
					"secure_spot_price": schema.NumberAttribute{
						Computed: true,
					},
					"six_month_price": schema.NumberAttribute{
						Computed: true,
					},
					"three_month_price": schema.NumberAttribute{
						Computed: true,
					},
				},
				CustomType: GpuType{
					ObjectType: types.ObjectType{
						AttrTypes: GpuValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"gpu_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, the number of GPUs attached to the created Pod.",
				MarkdownDescription: "If the created Pod is a GPU Pod, the number of GPUs attached to the created Pod.",
				Validators: []validator.Int64{
					int64validator.AtLeast(1),
				},
				Default: int64default.StaticInt64(1),
			},
			"gpu_type_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, a list of RunPod GPU types which can be attached to the created Pod. The order of the list determines the order to rent GPU types. See `gpuTypePriority` for information on how the order of the list affects Pod creation.",
				MarkdownDescription: "If the created Pod is a GPU Pod, a list of RunPod GPU types which can be attached to the created Pod. The order of the list determines the order to rent GPU types. See `gpuTypePriority` for information on how the order of the list affects Pod creation.",
			},
			"gpu_type_priority": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, set to availability to respond to current GPU type availability. Set to custom to always try to rent GPU types in the order specified in gpuTypeIds.",
				MarkdownDescription: "If the created Pod is a GPU Pod, set to availability to respond to current GPU type availability. Set to custom to always try to rent GPU types in the order specified in gpuTypeIds.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"availability",
						"custom",
					),
				},
				Default: stringdefault.StaticString("availability"),
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "A unique string identifying a [Pod](#/components/schema/Pod).",
				MarkdownDescription: "A unique string identifying a [Pod](#/components/schema/Pod).",
			},
			"image": schema.StringAttribute{
				Computed:            true,
				Description:         "The image tag for the container run on a Pod.",
				MarkdownDescription: "The image tag for the container run on a Pod.",
			},
			"image_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The image tag for the container run on the created Pod.",
				MarkdownDescription: "The image tag for the container run on the created Pod.",
			},
			"include_machine": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the machine the Pod is running on.",
				MarkdownDescription: "Include information about the machine the Pod is running on.",
				Default:             booldefault.StaticBool(false),
			},
			"include_network_volume": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the network volume attached to the returned Pod, if any.",
				MarkdownDescription: "Include information about the network volume attached to the returned Pod, if any.",
				Default:             booldefault.StaticBool(false),
			},
			"include_savings_plans": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the savings plans applied to the Pod.",
				MarkdownDescription: "Include information about the savings plans applied to the Pod.",
				Default:             booldefault.StaticBool(false),
			},
			"include_template": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the template the Pod uses, if any.",
				MarkdownDescription: "Include information about the template the Pod uses, if any.",
				Default:             booldefault.StaticBool(false),
			},
			"include_workers": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true to also list Pods which are Serverless workers.",
				MarkdownDescription: "Set to true to also list Pods which are Serverless workers.",
				Default:             booldefault.StaticBool(false),
			},
			"interruptible": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true to create an interruptible or spot Pod. An interruptible Pod can be rented at a lower cost but can be stopped at any time to free up resources for another Pod. A reserved Pod is rented at a higher cost but runs until it exits or is manually stopped.",
				MarkdownDescription: "Set to true to create an interruptible or spot Pod. An interruptible Pod can be rented at a lower cost but can be stopped at any time to free up resources for another Pod. A reserved Pod is rented at a higher cost but runs until it exits or is manually stopped.",
				Default:             booldefault.StaticBool(false),
			},
			"last_started_at": schema.StringAttribute{
				Computed:            true,
				Description:         "The UTC timestamp when a Pod was last started.",
				MarkdownDescription: "The UTC timestamp when a Pod was last started.",
			},
			"last_status_change": schema.StringAttribute{
				Computed:            true,
				Description:         "A string describing the last lifecycle event on a Pod.",
				MarkdownDescription: "A string describing the last lifecycle event on a Pod.",
			},
			"locked": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true to lock a Pod. Locking a Pod disables stopping or resetting the Pod.",
				MarkdownDescription: "Set to true to lock a Pod. Locking a Pod disables stopping or resetting the Pod.",
				Default:             booldefault.StaticBool(false),
			},
			"machine": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cost_per_hr": schema.NumberAttribute{
						Computed: true,
					},
					"cpu_count": schema.Int64Attribute{
						Computed: true,
					},
					"cpu_type": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cores": schema.NumberAttribute{
								Computed: true,
							},
							"display_name": schema.StringAttribute{
								Computed: true,
							},
							"group_id": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"threads_per_core": schema.NumberAttribute{
								Computed: true,
							},
						},
						CustomType: CpuTypeType{
							ObjectType: types.ObjectType{
								AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"cpu_type_id": schema.StringAttribute{
						Computed: true,
					},
					"current_price_per_gpu": schema.NumberAttribute{
						Computed: true,
					},
					"data_center_id": schema.StringAttribute{
						Computed: true,
					},
					"disk_throughput_mbps": schema.Int64Attribute{
						Computed: true,
					},
					"gpu_available": schema.Int64Attribute{
						Computed: true,
					},
					"gpu_display_name": schema.StringAttribute{
						Computed: true,
					},
					"gpu_type": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"community_price": schema.NumberAttribute{
								Computed: true,
							},
							"community_spot_price": schema.NumberAttribute{
								Computed: true,
							},
							"count": schema.Int64Attribute{
								Computed:            true,
								Description:         "The number of GPUs attached to a Pod.",
								MarkdownDescription: "The number of GPUs attached to a Pod.",
							},
							"display_name": schema.StringAttribute{
								Computed: true,
							},
							"id": schema.StringAttribute{
								Computed: true,
							},
							"one_month_price": schema.NumberAttribute{
								Computed: true,
							},
							"one_week_price": schema.NumberAttribute{
								Computed: true,
							},
							"secure_price": schema.NumberAttribute{
								Computed: true,
							},
							"secure_spot_price": schema.NumberAttribute{
								Computed: true,
							},
							"six_month_price": schema.NumberAttribute{
								Computed: true,
							},
							"three_month_price": schema.NumberAttribute{
								Computed: true,
							},
						},
						CustomType: GpuTypeType{
							ObjectType: types.ObjectType{
								AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"gpu_type_id": schema.StringAttribute{
						Computed: true,
					},
					"location": schema.StringAttribute{
						Computed: true,
					},
					"maintenance_end": schema.StringAttribute{
						Computed: true,
					},
					"maintenance_note": schema.StringAttribute{
						Computed: true,
					},
					"maintenance_start": schema.StringAttribute{
						Computed: true,
					},
					"max_download_speed_mbps": schema.Int64Attribute{
						Computed: true,
					},
					"max_upload_speed_mbps": schema.Int64Attribute{
						Computed: true,
					},
					"min_pod_gpu_count": schema.Int64Attribute{
						Computed: true,
					},
					"note": schema.StringAttribute{
						Computed: true,
					},
					"secure_cloud": schema.BoolAttribute{
						Computed: true,
					},
					"support_public_ip": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: MachineType{
					ObjectType: types.ObjectType{
						AttrTypes: MachineValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Information about the machine a Pod is running on (see [Machine](#/components/schemas/Machine)).",
				MarkdownDescription: "Information about the machine a Pod is running on (see [Machine](#/components/schemas/Machine)).",
			},
			"machine_id": schema.StringAttribute{
				Computed:            true,
				Description:         "A unique string identifying the host machine a Pod is running on.",
				MarkdownDescription: "A unique string identifying the host machine a Pod is running on.",
			},
			"memory_in_gb": schema.NumberAttribute{
				Computed:            true,
				Description:         "The amount of RAM, in gigabytes (GB), attached to a Pod.",
				MarkdownDescription: "The amount of RAM, in gigabytes (GB), attached to a Pod.",
			},
			"min_disk_bandwidth_mbps": schema.NumberAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum disk bandwidth, in megabytes per second (MBps), for the created Pod.",
				MarkdownDescription: "The minimum disk bandwidth, in megabytes per second (MBps), for the created Pod.",
			},
			"min_download_mbps": schema.NumberAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum download speed, in megabits per second (Mbps), for the created Pod.",
				MarkdownDescription: "The minimum download speed, in megabits per second (Mbps), for the created Pod.",
			},
			"min_ramper_gpu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, the minimum amount of RAM, in gigabytes (GB), allocated to the created Pod for each GPU attached to the Pod.",
				MarkdownDescription: "If the created Pod is a GPU Pod, the minimum amount of RAM, in gigabytes (GB), allocated to the created Pod for each GPU attached to the Pod.",
				Default:             int64default.StaticInt64(8),
			},
			"min_upload_mbps": schema.NumberAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum upload speed, in megabits per second (Mbps), for the created Pod.",
				MarkdownDescription: "The minimum upload speed, in megabits per second (Mbps), for the created Pod.",
			},
			"min_vcpuper_gpu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a GPU Pod, the minimum number of virtual CPUs allocated to the created Pod for each GPU attached to the Pod.",
				MarkdownDescription: "If the created Pod is a GPU Pod, the minimum number of virtual CPUs allocated to the created Pod for each GPU attached to the Pod.",
				Default:             int64default.StaticInt64(2),
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A user-defined name for the created Pod. The name does not need to be unique.",
				MarkdownDescription: "A user-defined name for the created Pod. The name does not need to be unique.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(191),
				},
				Default: stringdefault.StaticString("my pod"),
			},
			"network_volume": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"data_center_id": schema.StringAttribute{
						Computed:            true,
						Description:         "The RunPod data center ID where a network volume is located.",
						MarkdownDescription: "The RunPod data center ID where a network volume is located.",
					},
					"id": schema.StringAttribute{
						Computed:            true,
						Description:         "A unique string identifying a network volume.",
						MarkdownDescription: "A unique string identifying a network volume.",
					},
					"name": schema.StringAttribute{
						Computed:            true,
						Description:         "A user-defined name for a network volume. The name does not need to be unique.",
						MarkdownDescription: "A user-defined name for a network volume. The name does not need to be unique.",
					},
					"size": schema.Int64Attribute{
						Computed:            true,
						Description:         "The amount of disk space, in gigabytes (GB), allocated to a network volume.",
						MarkdownDescription: "The amount of disk space, in gigabytes (GB), allocated to a network volume.",
					},
				},
				CustomType: NetworkVolumeType{
					ObjectType: types.ObjectType{
						AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "If a network volume is attached to a Pod, information about the network volume (see [network volume schema](#/components/schemas/NetworkVolume)).",
				MarkdownDescription: "If a network volume is attached to a Pod, information about the network volume (see [network volume schema](#/components/schemas/NetworkVolume)).",
			},
			"network_volume_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The unique string identifying the network volume to attach to the created Pod. If attached, a network volume replaces the Pod network volume.",
				MarkdownDescription: "The unique string identifying the network volume to attach to the created Pod. If attached, a network volume replaces the Pod network volume.",
			},
			"pod_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of Pod to return.",
				MarkdownDescription: "ID of Pod to return.",
			},
			"port_mappings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: PortMappingsType{
					ObjectType: types.ObjectType{
						AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "A mapping of internal ports to public ports on a Pod. For example, { \"22\": 10341 } means that port 22 on the Pod is mapped to port 10341 and is publicly accessible at [public ip]:10341. If the Pod is still initializing, this mapping is not yet determined and will be empty.",
				MarkdownDescription: "A mapping of internal ports to public ports on a Pod. For example, { \"22\": 10341 } means that port 22 on the Pod is mapped to port 10341 and is publicly accessible at [public ip]:10341. If the Pod is still initializing, this mapping is not yet determined and will be empty.",
			},
			"ports": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "A list of ports exposed on the created Pod. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
				MarkdownDescription: "A list of ports exposed on the created Pod. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
			},
			"public_ip": schema.StringAttribute{
				Computed:            true,
				Description:         "The public IP address of a Pod. If the Pod is still initializing, this IP is not yet determined and will be empty.",
				MarkdownDescription: "The public IP address of a Pod. If the Pod is still initializing, this IP is not yet determined and will be empty.",
			},
			"savings_plans": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"cost_per_hr": schema.NumberAttribute{
							Computed: true,
						},
						"end_time": schema.StringAttribute{
							Computed: true,
						},
						"gpu_type_id": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"pod_id": schema.StringAttribute{
							Computed: true,
						},
						"start_time": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: SavingsPlansType{
						ObjectType: types.ObjectType{
							AttrTypes: SavingsPlansValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The list of active Savings Plans applied to a Pod (see [Savings Plans](#/components/schemas/SavingsPlan)). If none are applied, the list is empty.",
				MarkdownDescription: "The list of active Savings Plans applied to a Pod (see [Savings Plans](#/components/schemas/SavingsPlan)). If none are applied, the list is empty.",
			},
			"sls_version": schema.Int64Attribute{
				Computed:            true,
				Description:         "If the Pod is a Serverless worker, the version of the associated endpoint (see [Endpoint Version](#/components/schemas/Endpoint/version)).",
				MarkdownDescription: "If the Pod is a Serverless worker, the version of the associated endpoint (see [Endpoint Version](#/components/schemas/Endpoint/version)).",
			},
			"support_public_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is on Community Cloud, set to true if you need the Pod to expose a public IP address. If null, the Pod might not have a public IP address. On Secure Cloud, the Pod will always have a public IP address.",
				MarkdownDescription: "If the created Pod is on Community Cloud, set to true if you need the Pod to expose a public IP address. If null, the Pod might not have a public IP address. On Secure Cloud, the Pod will always have a public IP address.",
			},
			"template_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the Pod is created with a template, the unique string identifying that template.",
				MarkdownDescription: "If the Pod is created with a template, the unique string identifying that template.",
			},
			"vcpu_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Pod is a CPU Pod, the number of vCPUs allocated to the Pod.",
				MarkdownDescription: "If the created Pod is a CPU Pod, the number of vCPUs allocated to the Pod.",
				Default:             int64default.StaticInt64(2),
			},
			"volume_encrypted": schema.BoolAttribute{
				Computed:            true,
				Description:         "Set to true if the local network volume of a Pod is encrypted. Can only be set when creating a Pod.",
				MarkdownDescription: "Set to true if the local network volume of a Pod is encrypted. Can only be set when creating a Pod.",
			},
			"volume_in_gb": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The amount of disk space, in gigabytes (GB), to allocate on the Pod volume for the created Pod. The data on the Pod volume is persisted across Pod restarts. To persist data so that future Pods can access it, create a network volume and set networkVolumeId to attach it to the Pod.",
				MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the Pod volume for the created Pod. The data on the Pod volume is persisted across Pod restarts. To persist data so that future Pods can access it, create a network volume and set networkVolumeId to attach it to the Pod.",
				Default:             int64default.StaticInt64(20),
			},
			"volume_mount_path": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If either a Pod volume or a network volume is attached to a Pod, the absolute path where the network volume will be mounted in the filesystem.",
				MarkdownDescription: "If either a Pod volume or a network volume is attached to a Pod, the absolute path where the network volume will be mounted in the filesystem.",
				Default:             stringdefault.StaticString("/workspace"),
			},
		},
	}
}

type PodModel struct {
	AdjustedCostPerHr       types.Number       `tfsdk:"adjusted_cost_per_hr"`
	AiApiId                 types.String       `tfsdk:"ai_api_id"`
	AllowedCudaVersions     types.List         `tfsdk:"allowed_cuda_versions"`
	CloudType               types.String       `tfsdk:"cloud_type"`
	ComputeType             types.String       `tfsdk:"compute_type"`
	ConsumerUserId          types.String       `tfsdk:"consumer_user_id"`
	ContainerDiskInGb       types.Int64        `tfsdk:"container_disk_in_gb"`
	ContainerRegistryAuthId types.String       `tfsdk:"container_registry_auth_id"`
	CostPerHr               types.Number       `tfsdk:"cost_per_hr"`
	CountryCodes            types.List         `tfsdk:"country_codes"`
	CpuFlavorId             types.String       `tfsdk:"cpu_flavor_id"`
	CpuFlavorIds            types.List         `tfsdk:"cpu_flavor_ids"`
	CpuFlavorPriority       types.String       `tfsdk:"cpu_flavor_priority"`
	DataCenterIds           types.List         `tfsdk:"data_center_ids"`
	DataCenterPriority      types.String       `tfsdk:"data_center_priority"`
	DesiredStatus           types.String       `tfsdk:"desired_status"`
	DockerEntrypoint        types.List         `tfsdk:"docker_entrypoint"`
	DockerStartCmd          types.List         `tfsdk:"docker_start_cmd"`
	EndpointId              types.String       `tfsdk:"endpoint_id"`
	Env                     EnvValue           `tfsdk:"env"`
	GlobalNetworking        types.Bool         `tfsdk:"global_networking"`
	Gpu                     GpuValue           `tfsdk:"gpu"`
	GpuCount                types.Int64        `tfsdk:"gpu_count"`
	GpuTypeIds              types.List         `tfsdk:"gpu_type_ids"`
	GpuTypePriority         types.String       `tfsdk:"gpu_type_priority"`
	Id                      types.String       `tfsdk:"id"`
	Image                   types.String       `tfsdk:"image"`
	ImageName               types.String       `tfsdk:"image_name"`
	IncludeMachine          types.Bool         `tfsdk:"include_machine"`
	IncludeNetworkVolume    types.Bool         `tfsdk:"include_network_volume"`
	IncludeSavingsPlans     types.Bool         `tfsdk:"include_savings_plans"`
	IncludeTemplate         types.Bool         `tfsdk:"include_template"`
	IncludeWorkers          types.Bool         `tfsdk:"include_workers"`
	Interruptible           types.Bool         `tfsdk:"interruptible"`
	LastStartedAt           types.String       `tfsdk:"last_started_at"`
	LastStatusChange        types.String       `tfsdk:"last_status_change"`
	Locked                  types.Bool         `tfsdk:"locked"`
	Machine                 MachineValue       `tfsdk:"machine"`
	MachineId               types.String       `tfsdk:"machine_id"`
	MemoryInGb              types.Number       `tfsdk:"memory_in_gb"`
	MinDiskBandwidthMbps    types.Number       `tfsdk:"min_disk_bandwidth_mbps"`
	MinDownloadMbps         types.Number       `tfsdk:"min_download_mbps"`
	MinRamperGpu            types.Int64        `tfsdk:"min_ramper_gpu"`
	MinUploadMbps           types.Number       `tfsdk:"min_upload_mbps"`
	MinVcpuperGpu           types.Int64        `tfsdk:"min_vcpuper_gpu"`
	Name                    types.String       `tfsdk:"name"`
	NetworkVolume           NetworkVolumeValue `tfsdk:"network_volume"`
	NetworkVolumeId         types.String       `tfsdk:"network_volume_id"`
	PodId                   types.String       `tfsdk:"pod_id"`
	PortMappings            PortMappingsValue  `tfsdk:"port_mappings"`
	Ports                   types.List         `tfsdk:"ports"`
	PublicIp                types.String       `tfsdk:"public_ip"`
	SavingsPlans            types.List         `tfsdk:"savings_plans"`
	SlsVersion              types.Int64        `tfsdk:"sls_version"`
	SupportPublicIp         types.Bool         `tfsdk:"support_public_ip"`
	TemplateId              types.String       `tfsdk:"template_id"`
	VcpuCount               types.Int64        `tfsdk:"vcpu_count"`
	VolumeEncrypted         types.Bool         `tfsdk:"volume_encrypted"`
	VolumeInGb              types.Int64        `tfsdk:"volume_in_gb"`
	VolumeMountPath         types.String       `tfsdk:"volume_mount_path"`
}

var _ basetypes.ObjectTypable = EnvType{}

type EnvType struct {
	basetypes.ObjectType
}

func (t EnvType) Equal(o attr.Type) bool {
	other, ok := o.(EnvType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvType) String() string {
	return "EnvType"
}

func (t EnvType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return EnvValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvValueNull() EnvValue {
	return EnvValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvValueUnknown() EnvValue {
	return EnvValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvValue Attribute Value",
				"While creating a EnvValue value, a missing attribute value was detected. "+
					"A EnvValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvValue Attribute Type",
				"While creating a EnvValue value, an invalid attribute value was detected. "+
					"A EnvValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvValue Attribute Value",
				"While creating a EnvValue value, an extra attribute value was detected. "+
					"A EnvValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvValueUnknown(), diags
	}

	if diags.HasError() {
		return NewEnvValueUnknown(), diags
	}

	return EnvValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvValue {
	object, diags := NewEnvValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvValueMust(EnvValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvType) ValueType(ctx context.Context) attr.Value {
	return EnvValue{}
}

var _ basetypes.ObjectValuable = EnvValue{}

type EnvValue struct {
	state attr.ValueState
}

func (v EnvValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvValue) String() string {
	return "EnvValue"
}

func (v EnvValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v EnvValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v EnvValue) Type(ctx context.Context) attr.Type {
	return EnvType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = GpuType{}

type GpuType struct {
	basetypes.ObjectType
}

func (t GpuType) Equal(o attr.Type) bool {
	other, ok := o.(GpuType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GpuType) String() string {
	return "GpuType"
}

func (t GpuType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return nil, diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return nil, diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return nil, diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return nil, diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return nil, diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return nil, diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return nil, diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return nil, diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GpuValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuValueNull() GpuValue {
	return GpuValue{
		state: attr.ValueStateNull,
	}
}

func NewGpuValueUnknown() GpuValue {
	return GpuValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGpuValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GpuValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GpuValue Attribute Value",
				"While creating a GpuValue value, a missing attribute value was detected. "+
					"A GpuValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GpuValue Attribute Type",
				"While creating a GpuValue value, an invalid attribute value was detected. "+
					"A GpuValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GpuValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GpuValue Attribute Value",
				"While creating a GpuValue value, an extra attribute value was detected. "+
					"A GpuValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GpuValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGpuValueUnknown(), diags
	}

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return NewGpuValueUnknown(), diags
	}

	return GpuValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GpuValue {
	object, diags := NewGpuValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGpuValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GpuType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGpuValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGpuValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGpuValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGpuValueMust(GpuValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GpuType) ValueType(ctx context.Context) attr.Value {
	return GpuValue{}
}

var _ basetypes.ObjectValuable = GpuValue{}

type GpuValue struct {
	CommunityPrice     basetypes.NumberValue `tfsdk:"community_price"`
	CommunitySpotPrice basetypes.NumberValue `tfsdk:"community_spot_price"`
	Count              basetypes.Int64Value  `tfsdk:"count"`
	DisplayName        basetypes.StringValue `tfsdk:"display_name"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	OneMonthPrice      basetypes.NumberValue `tfsdk:"one_month_price"`
	OneWeekPrice       basetypes.NumberValue `tfsdk:"one_week_price"`
	SecurePrice        basetypes.NumberValue `tfsdk:"secure_price"`
	SecureSpotPrice    basetypes.NumberValue `tfsdk:"secure_spot_price"`
	SixMonthPrice      basetypes.NumberValue `tfsdk:"six_month_price"`
	ThreeMonthPrice    basetypes.NumberValue `tfsdk:"three_month_price"`
	state              attr.ValueState
}

func (v GpuValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["community_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["community_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["one_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["one_week_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["six_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["three_month_price"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CommunityPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_price"] = val

		val, err = v.CommunitySpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_spot_price"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.OneMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_month_price"] = val

		val, err = v.OneWeekPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_week_price"] = val

		val, err = v.SecurePrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_price"] = val

		val, err = v.SecureSpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_spot_price"] = val

		val, err = v.SixMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["six_month_price"] = val

		val, err = v.ThreeMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["three_month_price"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GpuValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GpuValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GpuValue) String() string {
	return "GpuValue"
}

func (v GpuValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"community_price":      v.CommunityPrice,
			"community_spot_price": v.CommunitySpotPrice,
			"count":                v.Count,
			"display_name":         v.DisplayName,
			"id":                   v.Id,
			"one_month_price":      v.OneMonthPrice,
			"one_week_price":       v.OneWeekPrice,
			"secure_price":         v.SecurePrice,
			"secure_spot_price":    v.SecureSpotPrice,
			"six_month_price":      v.SixMonthPrice,
			"three_month_price":    v.ThreeMonthPrice,
		})

	return objVal, diags
}

func (v GpuValue) Equal(o attr.Value) bool {
	other, ok := o.(GpuValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommunityPrice.Equal(other.CommunityPrice) {
		return false
	}

	if !v.CommunitySpotPrice.Equal(other.CommunitySpotPrice) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.OneMonthPrice.Equal(other.OneMonthPrice) {
		return false
	}

	if !v.OneWeekPrice.Equal(other.OneWeekPrice) {
		return false
	}

	if !v.SecurePrice.Equal(other.SecurePrice) {
		return false
	}

	if !v.SecureSpotPrice.Equal(other.SecureSpotPrice) {
		return false
	}

	if !v.SixMonthPrice.Equal(other.SixMonthPrice) {
		return false
	}

	if !v.ThreeMonthPrice.Equal(other.ThreeMonthPrice) {
		return false
	}

	return true
}

func (v GpuValue) Type(ctx context.Context) attr.Type {
	return GpuType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GpuValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = MachineType{}

type MachineType struct {
	basetypes.ObjectType
}

func (t MachineType) Equal(o attr.Type) bool {
	other, ok := o.(MachineType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MachineType) String() string {
	return "MachineType"
}

func (t MachineType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return nil, diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuCountAttribute, ok := attributes["cpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_count is missing from object`)

		return nil, diags
	}

	cpuCountVal, ok := cpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_count expected to be basetypes.Int64Value, was: %T`, cpuCountAttribute))
	}

	cpuTypeAttribute, ok := attributes["cpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type is missing from object`)

		return nil, diags
	}

	cpuTypeVal, ok := cpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type expected to be basetypes.ObjectValue, was: %T`, cpuTypeAttribute))
	}

	cpuTypeIdAttribute, ok := attributes["cpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type_id is missing from object`)

		return nil, diags
	}

	cpuTypeIdVal, ok := cpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type_id expected to be basetypes.StringValue, was: %T`, cpuTypeIdAttribute))
	}

	currentPricePerGpuAttribute, ok := attributes["current_price_per_gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_price_per_gpu is missing from object`)

		return nil, diags
	}

	currentPricePerGpuVal, ok := currentPricePerGpuAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_price_per_gpu expected to be basetypes.NumberValue, was: %T`, currentPricePerGpuAttribute))
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return nil, diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	diskThroughputMbpsAttribute, ok := attributes["disk_throughput_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_throughput_mbps is missing from object`)

		return nil, diags
	}

	diskThroughputMbpsVal, ok := diskThroughputMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_throughput_mbps expected to be basetypes.Int64Value, was: %T`, diskThroughputMbpsAttribute))
	}

	gpuAvailableAttribute, ok := attributes["gpu_available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_available is missing from object`)

		return nil, diags
	}

	gpuAvailableVal, ok := gpuAvailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_available expected to be basetypes.Int64Value, was: %T`, gpuAvailableAttribute))
	}

	gpuDisplayNameAttribute, ok := attributes["gpu_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_display_name is missing from object`)

		return nil, diags
	}

	gpuDisplayNameVal, ok := gpuDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_display_name expected to be basetypes.StringValue, was: %T`, gpuDisplayNameAttribute))
	}

	gpuTypeAttribute, ok := attributes["gpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type is missing from object`)

		return nil, diags
	}

	gpuTypeVal, ok := gpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type expected to be basetypes.ObjectValue, was: %T`, gpuTypeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return nil, diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	maintenanceEndAttribute, ok := attributes["maintenance_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_end is missing from object`)

		return nil, diags
	}

	maintenanceEndVal, ok := maintenanceEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_end expected to be basetypes.StringValue, was: %T`, maintenanceEndAttribute))
	}

	maintenanceNoteAttribute, ok := attributes["maintenance_note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_note is missing from object`)

		return nil, diags
	}

	maintenanceNoteVal, ok := maintenanceNoteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_note expected to be basetypes.StringValue, was: %T`, maintenanceNoteAttribute))
	}

	maintenanceStartAttribute, ok := attributes["maintenance_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_start is missing from object`)

		return nil, diags
	}

	maintenanceStartVal, ok := maintenanceStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_start expected to be basetypes.StringValue, was: %T`, maintenanceStartAttribute))
	}

	maxDownloadSpeedMbpsAttribute, ok := attributes["max_download_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_download_speed_mbps is missing from object`)

		return nil, diags
	}

	maxDownloadSpeedMbpsVal, ok := maxDownloadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_download_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxDownloadSpeedMbpsAttribute))
	}

	maxUploadSpeedMbpsAttribute, ok := attributes["max_upload_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_upload_speed_mbps is missing from object`)

		return nil, diags
	}

	maxUploadSpeedMbpsVal, ok := maxUploadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_upload_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxUploadSpeedMbpsAttribute))
	}

	minPodGpuCountAttribute, ok := attributes["min_pod_gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_pod_gpu_count is missing from object`)

		return nil, diags
	}

	minPodGpuCountVal, ok := minPodGpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_pod_gpu_count expected to be basetypes.Int64Value, was: %T`, minPodGpuCountAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return nil, diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	secureCloudAttribute, ok := attributes["secure_cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_cloud is missing from object`)

		return nil, diags
	}

	secureCloudVal, ok := secureCloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_cloud expected to be basetypes.BoolValue, was: %T`, secureCloudAttribute))
	}

	supportPublicIpAttribute, ok := attributes["support_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`support_public_ip is missing from object`)

		return nil, diags
	}

	supportPublicIpVal, ok := supportPublicIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`support_public_ip expected to be basetypes.BoolValue, was: %T`, supportPublicIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MachineValue{
		CostPerHr:            costPerHrVal,
		CpuCount:             cpuCountVal,
		CpuType:              cpuTypeVal,
		CpuTypeId:            cpuTypeIdVal,
		CurrentPricePerGpu:   currentPricePerGpuVal,
		DataCenterId:         dataCenterIdVal,
		DiskThroughputMbps:   diskThroughputMbpsVal,
		GpuAvailable:         gpuAvailableVal,
		GpuDisplayName:       gpuDisplayNameVal,
		GpuType:              gpuTypeVal,
		GpuTypeId:            gpuTypeIdVal,
		Location:             locationVal,
		MaintenanceEnd:       maintenanceEndVal,
		MaintenanceNote:      maintenanceNoteVal,
		MaintenanceStart:     maintenanceStartVal,
		MaxDownloadSpeedMbps: maxDownloadSpeedMbpsVal,
		MaxUploadSpeedMbps:   maxUploadSpeedMbpsVal,
		MinPodGpuCount:       minPodGpuCountVal,
		Note:                 noteVal,
		SecureCloud:          secureCloudVal,
		SupportPublicIp:      supportPublicIpVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMachineValueNull() MachineValue {
	return MachineValue{
		state: attr.ValueStateNull,
	}
}

func NewMachineValueUnknown() MachineValue {
	return MachineValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMachineValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MachineValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MachineValue Attribute Value",
				"While creating a MachineValue value, a missing attribute value was detected. "+
					"A MachineValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MachineValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MachineValue Attribute Type",
				"While creating a MachineValue value, an invalid attribute value was detected. "+
					"A MachineValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MachineValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MachineValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MachineValue Attribute Value",
				"While creating a MachineValue value, an extra attribute value was detected. "+
					"A MachineValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MachineValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMachineValueUnknown(), diags
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuCountAttribute, ok := attributes["cpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_count is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuCountVal, ok := cpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_count expected to be basetypes.Int64Value, was: %T`, cpuCountAttribute))
	}

	cpuTypeAttribute, ok := attributes["cpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuTypeVal, ok := cpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type expected to be basetypes.ObjectValue, was: %T`, cpuTypeAttribute))
	}

	cpuTypeIdAttribute, ok := attributes["cpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuTypeIdVal, ok := cpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type_id expected to be basetypes.StringValue, was: %T`, cpuTypeIdAttribute))
	}

	currentPricePerGpuAttribute, ok := attributes["current_price_per_gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_price_per_gpu is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	currentPricePerGpuVal, ok := currentPricePerGpuAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_price_per_gpu expected to be basetypes.NumberValue, was: %T`, currentPricePerGpuAttribute))
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	diskThroughputMbpsAttribute, ok := attributes["disk_throughput_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_throughput_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	diskThroughputMbpsVal, ok := diskThroughputMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_throughput_mbps expected to be basetypes.Int64Value, was: %T`, diskThroughputMbpsAttribute))
	}

	gpuAvailableAttribute, ok := attributes["gpu_available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_available is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuAvailableVal, ok := gpuAvailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_available expected to be basetypes.Int64Value, was: %T`, gpuAvailableAttribute))
	}

	gpuDisplayNameAttribute, ok := attributes["gpu_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_display_name is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuDisplayNameVal, ok := gpuDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_display_name expected to be basetypes.StringValue, was: %T`, gpuDisplayNameAttribute))
	}

	gpuTypeAttribute, ok := attributes["gpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuTypeVal, ok := gpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type expected to be basetypes.ObjectValue, was: %T`, gpuTypeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	maintenanceEndAttribute, ok := attributes["maintenance_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_end is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceEndVal, ok := maintenanceEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_end expected to be basetypes.StringValue, was: %T`, maintenanceEndAttribute))
	}

	maintenanceNoteAttribute, ok := attributes["maintenance_note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_note is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceNoteVal, ok := maintenanceNoteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_note expected to be basetypes.StringValue, was: %T`, maintenanceNoteAttribute))
	}

	maintenanceStartAttribute, ok := attributes["maintenance_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_start is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceStartVal, ok := maintenanceStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_start expected to be basetypes.StringValue, was: %T`, maintenanceStartAttribute))
	}

	maxDownloadSpeedMbpsAttribute, ok := attributes["max_download_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_download_speed_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maxDownloadSpeedMbpsVal, ok := maxDownloadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_download_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxDownloadSpeedMbpsAttribute))
	}

	maxUploadSpeedMbpsAttribute, ok := attributes["max_upload_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_upload_speed_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maxUploadSpeedMbpsVal, ok := maxUploadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_upload_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxUploadSpeedMbpsAttribute))
	}

	minPodGpuCountAttribute, ok := attributes["min_pod_gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_pod_gpu_count is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	minPodGpuCountVal, ok := minPodGpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_pod_gpu_count expected to be basetypes.Int64Value, was: %T`, minPodGpuCountAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	secureCloudAttribute, ok := attributes["secure_cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_cloud is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	secureCloudVal, ok := secureCloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_cloud expected to be basetypes.BoolValue, was: %T`, secureCloudAttribute))
	}

	supportPublicIpAttribute, ok := attributes["support_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`support_public_ip is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	supportPublicIpVal, ok := supportPublicIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`support_public_ip expected to be basetypes.BoolValue, was: %T`, supportPublicIpAttribute))
	}

	if diags.HasError() {
		return NewMachineValueUnknown(), diags
	}

	return MachineValue{
		CostPerHr:            costPerHrVal,
		CpuCount:             cpuCountVal,
		CpuType:              cpuTypeVal,
		CpuTypeId:            cpuTypeIdVal,
		CurrentPricePerGpu:   currentPricePerGpuVal,
		DataCenterId:         dataCenterIdVal,
		DiskThroughputMbps:   diskThroughputMbpsVal,
		GpuAvailable:         gpuAvailableVal,
		GpuDisplayName:       gpuDisplayNameVal,
		GpuType:              gpuTypeVal,
		GpuTypeId:            gpuTypeIdVal,
		Location:             locationVal,
		MaintenanceEnd:       maintenanceEndVal,
		MaintenanceNote:      maintenanceNoteVal,
		MaintenanceStart:     maintenanceStartVal,
		MaxDownloadSpeedMbps: maxDownloadSpeedMbpsVal,
		MaxUploadSpeedMbps:   maxUploadSpeedMbpsVal,
		MinPodGpuCount:       minPodGpuCountVal,
		Note:                 noteVal,
		SecureCloud:          secureCloudVal,
		SupportPublicIp:      supportPublicIpVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMachineValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MachineValue {
	object, diags := NewMachineValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMachineValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MachineType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMachineValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMachineValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMachineValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMachineValueMust(MachineValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MachineType) ValueType(ctx context.Context) attr.Value {
	return MachineValue{}
}

var _ basetypes.ObjectValuable = MachineValue{}

type MachineValue struct {
	CostPerHr            basetypes.NumberValue `tfsdk:"cost_per_hr"`
	CpuCount             basetypes.Int64Value  `tfsdk:"cpu_count"`
	CpuType              basetypes.ObjectValue `tfsdk:"cpu_type"`
	CpuTypeId            basetypes.StringValue `tfsdk:"cpu_type_id"`
	CurrentPricePerGpu   basetypes.NumberValue `tfsdk:"current_price_per_gpu"`
	DataCenterId         basetypes.StringValue `tfsdk:"data_center_id"`
	DiskThroughputMbps   basetypes.Int64Value  `tfsdk:"disk_throughput_mbps"`
	GpuAvailable         basetypes.Int64Value  `tfsdk:"gpu_available"`
	GpuDisplayName       basetypes.StringValue `tfsdk:"gpu_display_name"`
	GpuType              basetypes.ObjectValue `tfsdk:"gpu_type"`
	GpuTypeId            basetypes.StringValue `tfsdk:"gpu_type_id"`
	Location             basetypes.StringValue `tfsdk:"location"`
	MaintenanceEnd       basetypes.StringValue `tfsdk:"maintenance_end"`
	MaintenanceNote      basetypes.StringValue `tfsdk:"maintenance_note"`
	MaintenanceStart     basetypes.StringValue `tfsdk:"maintenance_start"`
	MaxDownloadSpeedMbps basetypes.Int64Value  `tfsdk:"max_download_speed_mbps"`
	MaxUploadSpeedMbps   basetypes.Int64Value  `tfsdk:"max_upload_speed_mbps"`
	MinPodGpuCount       basetypes.Int64Value  `tfsdk:"min_pod_gpu_count"`
	Note                 basetypes.StringValue `tfsdk:"note"`
	SecureCloud          basetypes.BoolValue   `tfsdk:"secure_cloud"`
	SupportPublicIp      basetypes.BoolValue   `tfsdk:"support_public_ip"`
	state                attr.ValueState
}

func (v MachineValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["cpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cpu_type"] = basetypes.ObjectType{
		AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["current_price_per_gpu"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["data_center_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk_throughput_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_available"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_type"] = basetypes.ObjectType{
		AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_note"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_download_speed_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_upload_speed_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_pod_gpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["note"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secure_cloud"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["support_public_ip"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.CostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost_per_hr"] = val

		val, err = v.CpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_count"] = val

		val, err = v.CpuType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_type"] = val

		val, err = v.CpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_type_id"] = val

		val, err = v.CurrentPricePerGpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_price_per_gpu"] = val

		val, err = v.DataCenterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_center_id"] = val

		val, err = v.DiskThroughputMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_throughput_mbps"] = val

		val, err = v.GpuAvailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_available"] = val

		val, err = v.GpuDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_display_name"] = val

		val, err = v.GpuType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type"] = val

		val, err = v.GpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type_id"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.MaintenanceEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_end"] = val

		val, err = v.MaintenanceNote.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_note"] = val

		val, err = v.MaintenanceStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_start"] = val

		val, err = v.MaxDownloadSpeedMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_download_speed_mbps"] = val

		val, err = v.MaxUploadSpeedMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_upload_speed_mbps"] = val

		val, err = v.MinPodGpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_pod_gpu_count"] = val

		val, err = v.Note.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["note"] = val

		val, err = v.SecureCloud.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_cloud"] = val

		val, err = v.SupportPublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["support_public_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MachineValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MachineValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MachineValue) String() string {
	return "MachineValue"
}

func (v MachineValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cpuType basetypes.ObjectValue

	if v.CpuType.IsNull() {
		cpuType = types.ObjectNull(
			CpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.CpuType.IsUnknown() {
		cpuType = types.ObjectUnknown(
			CpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CpuType.IsNull() && !v.CpuType.IsUnknown() {
		cpuType = types.ObjectValueMust(
			CpuTypeValue{}.AttributeTypes(ctx),
			v.CpuType.Attributes(),
		)
	}

	var gpuType basetypes.ObjectValue

	if v.GpuType.IsNull() {
		gpuType = types.ObjectNull(
			GpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.GpuType.IsUnknown() {
		gpuType = types.ObjectUnknown(
			GpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.GpuType.IsNull() && !v.GpuType.IsUnknown() {
		gpuType = types.ObjectValueMust(
			GpuTypeValue{}.AttributeTypes(ctx),
			v.GpuType.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"cpu_count":   basetypes.Int64Type{},
		"cpu_type": basetypes.ObjectType{
			AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
		},
		"cpu_type_id":           basetypes.StringType{},
		"current_price_per_gpu": basetypes.NumberType{},
		"data_center_id":        basetypes.StringType{},
		"disk_throughput_mbps":  basetypes.Int64Type{},
		"gpu_available":         basetypes.Int64Type{},
		"gpu_display_name":      basetypes.StringType{},
		"gpu_type": basetypes.ObjectType{
			AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
		},
		"gpu_type_id":             basetypes.StringType{},
		"location":                basetypes.StringType{},
		"maintenance_end":         basetypes.StringType{},
		"maintenance_note":        basetypes.StringType{},
		"maintenance_start":       basetypes.StringType{},
		"max_download_speed_mbps": basetypes.Int64Type{},
		"max_upload_speed_mbps":   basetypes.Int64Type{},
		"min_pod_gpu_count":       basetypes.Int64Type{},
		"note":                    basetypes.StringType{},
		"secure_cloud":            basetypes.BoolType{},
		"support_public_ip":       basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost_per_hr":             v.CostPerHr,
			"cpu_count":               v.CpuCount,
			"cpu_type":                cpuType,
			"cpu_type_id":             v.CpuTypeId,
			"current_price_per_gpu":   v.CurrentPricePerGpu,
			"data_center_id":          v.DataCenterId,
			"disk_throughput_mbps":    v.DiskThroughputMbps,
			"gpu_available":           v.GpuAvailable,
			"gpu_display_name":        v.GpuDisplayName,
			"gpu_type":                gpuType,
			"gpu_type_id":             v.GpuTypeId,
			"location":                v.Location,
			"maintenance_end":         v.MaintenanceEnd,
			"maintenance_note":        v.MaintenanceNote,
			"maintenance_start":       v.MaintenanceStart,
			"max_download_speed_mbps": v.MaxDownloadSpeedMbps,
			"max_upload_speed_mbps":   v.MaxUploadSpeedMbps,
			"min_pod_gpu_count":       v.MinPodGpuCount,
			"note":                    v.Note,
			"secure_cloud":            v.SecureCloud,
			"support_public_ip":       v.SupportPublicIp,
		})

	return objVal, diags
}

func (v MachineValue) Equal(o attr.Value) bool {
	other, ok := o.(MachineValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CostPerHr.Equal(other.CostPerHr) {
		return false
	}

	if !v.CpuCount.Equal(other.CpuCount) {
		return false
	}

	if !v.CpuType.Equal(other.CpuType) {
		return false
	}

	if !v.CpuTypeId.Equal(other.CpuTypeId) {
		return false
	}

	if !v.CurrentPricePerGpu.Equal(other.CurrentPricePerGpu) {
		return false
	}

	if !v.DataCenterId.Equal(other.DataCenterId) {
		return false
	}

	if !v.DiskThroughputMbps.Equal(other.DiskThroughputMbps) {
		return false
	}

	if !v.GpuAvailable.Equal(other.GpuAvailable) {
		return false
	}

	if !v.GpuDisplayName.Equal(other.GpuDisplayName) {
		return false
	}

	if !v.GpuType.Equal(other.GpuType) {
		return false
	}

	if !v.GpuTypeId.Equal(other.GpuTypeId) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.MaintenanceEnd.Equal(other.MaintenanceEnd) {
		return false
	}

	if !v.MaintenanceNote.Equal(other.MaintenanceNote) {
		return false
	}

	if !v.MaintenanceStart.Equal(other.MaintenanceStart) {
		return false
	}

	if !v.MaxDownloadSpeedMbps.Equal(other.MaxDownloadSpeedMbps) {
		return false
	}

	if !v.MaxUploadSpeedMbps.Equal(other.MaxUploadSpeedMbps) {
		return false
	}

	if !v.MinPodGpuCount.Equal(other.MinPodGpuCount) {
		return false
	}

	if !v.Note.Equal(other.Note) {
		return false
	}

	if !v.SecureCloud.Equal(other.SecureCloud) {
		return false
	}

	if !v.SupportPublicIp.Equal(other.SupportPublicIp) {
		return false
	}

	return true
}

func (v MachineValue) Type(ctx context.Context) attr.Type {
	return MachineType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MachineValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"cpu_count":   basetypes.Int64Type{},
		"cpu_type": basetypes.ObjectType{
			AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
		},
		"cpu_type_id":           basetypes.StringType{},
		"current_price_per_gpu": basetypes.NumberType{},
		"data_center_id":        basetypes.StringType{},
		"disk_throughput_mbps":  basetypes.Int64Type{},
		"gpu_available":         basetypes.Int64Type{},
		"gpu_display_name":      basetypes.StringType{},
		"gpu_type": basetypes.ObjectType{
			AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
		},
		"gpu_type_id":             basetypes.StringType{},
		"location":                basetypes.StringType{},
		"maintenance_end":         basetypes.StringType{},
		"maintenance_note":        basetypes.StringType{},
		"maintenance_start":       basetypes.StringType{},
		"max_download_speed_mbps": basetypes.Int64Type{},
		"max_upload_speed_mbps":   basetypes.Int64Type{},
		"min_pod_gpu_count":       basetypes.Int64Type{},
		"note":                    basetypes.StringType{},
		"secure_cloud":            basetypes.BoolType{},
		"support_public_ip":       basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CpuTypeType{}

type CpuTypeType struct {
	basetypes.ObjectType
}

func (t CpuTypeType) Equal(o attr.Type) bool {
	other, ok := o.(CpuTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuTypeType) String() string {
	return "CpuTypeType"
}

func (t CpuTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	coresAttribute, ok := attributes["cores"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cores is missing from object`)

		return nil, diags
	}

	coresVal, ok := coresAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cores expected to be basetypes.NumberValue, was: %T`, coresAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return nil, diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	threadsPerCoreAttribute, ok := attributes["threads_per_core"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threads_per_core is missing from object`)

		return nil, diags
	}

	threadsPerCoreVal, ok := threadsPerCoreAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threads_per_core expected to be basetypes.NumberValue, was: %T`, threadsPerCoreAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuTypeValue{
		Cores:          coresVal,
		DisplayName:    displayNameVal,
		GroupId:        groupIdVal,
		Id:             idVal,
		ThreadsPerCore: threadsPerCoreVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCpuTypeValueNull() CpuTypeValue {
	return CpuTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuTypeValueUnknown() CpuTypeValue {
	return CpuTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuTypeValue Attribute Value",
				"While creating a CpuTypeValue value, a missing attribute value was detected. "+
					"A CpuTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuTypeValue Attribute Type",
				"While creating a CpuTypeValue value, an invalid attribute value was detected. "+
					"A CpuTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuTypeValue Attribute Value",
				"While creating a CpuTypeValue value, an extra attribute value was detected. "+
					"A CpuTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuTypeValueUnknown(), diags
	}

	coresAttribute, ok := attributes["cores"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cores is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	coresVal, ok := coresAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cores expected to be basetypes.NumberValue, was: %T`, coresAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	threadsPerCoreAttribute, ok := attributes["threads_per_core"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threads_per_core is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	threadsPerCoreVal, ok := threadsPerCoreAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threads_per_core expected to be basetypes.NumberValue, was: %T`, threadsPerCoreAttribute))
	}

	if diags.HasError() {
		return NewCpuTypeValueUnknown(), diags
	}

	return CpuTypeValue{
		Cores:          coresVal,
		DisplayName:    displayNameVal,
		GroupId:        groupIdVal,
		Id:             idVal,
		ThreadsPerCore: threadsPerCoreVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCpuTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuTypeValue {
	object, diags := NewCpuTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuTypeValueMust(CpuTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuTypeType) ValueType(ctx context.Context) attr.Value {
	return CpuTypeValue{}
}

var _ basetypes.ObjectValuable = CpuTypeValue{}

type CpuTypeValue struct {
	Cores          basetypes.NumberValue `tfsdk:"cores"`
	DisplayName    basetypes.StringValue `tfsdk:"display_name"`
	GroupId        basetypes.StringValue `tfsdk:"group_id"`
	Id             basetypes.StringValue `tfsdk:"id"`
	ThreadsPerCore basetypes.NumberValue `tfsdk:"threads_per_core"`
	state          attr.ValueState
}

func (v CpuTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cores"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["threads_per_core"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cores.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cores"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.GroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ThreadsPerCore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threads_per_core"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuTypeValue) String() string {
	return "CpuTypeValue"
}

func (v CpuTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cores":            basetypes.NumberType{},
		"display_name":     basetypes.StringType{},
		"group_id":         basetypes.StringType{},
		"id":               basetypes.StringType{},
		"threads_per_core": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cores":            v.Cores,
			"display_name":     v.DisplayName,
			"group_id":         v.GroupId,
			"id":               v.Id,
			"threads_per_core": v.ThreadsPerCore,
		})

	return objVal, diags
}

func (v CpuTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cores.Equal(other.Cores) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.GroupId.Equal(other.GroupId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ThreadsPerCore.Equal(other.ThreadsPerCore) {
		return false
	}

	return true
}

func (v CpuTypeValue) Type(ctx context.Context) attr.Type {
	return CpuTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cores":            basetypes.NumberType{},
		"display_name":     basetypes.StringType{},
		"group_id":         basetypes.StringType{},
		"id":               basetypes.StringType{},
		"threads_per_core": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = GpuTypeType{}

type GpuTypeType struct {
	basetypes.ObjectType
}

func (t GpuTypeType) Equal(o attr.Type) bool {
	other, ok := o.(GpuTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GpuTypeType) String() string {
	return "GpuTypeType"
}

func (t GpuTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return nil, diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return nil, diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return nil, diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return nil, diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return nil, diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return nil, diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return nil, diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return nil, diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GpuTypeValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuTypeValueNull() GpuTypeValue {
	return GpuTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewGpuTypeValueUnknown() GpuTypeValue {
	return GpuTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGpuTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GpuTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GpuTypeValue Attribute Value",
				"While creating a GpuTypeValue value, a missing attribute value was detected. "+
					"A GpuTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GpuTypeValue Attribute Type",
				"While creating a GpuTypeValue value, an invalid attribute value was detected. "+
					"A GpuTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GpuTypeValue Attribute Value",
				"While creating a GpuTypeValue value, an extra attribute value was detected. "+
					"A GpuTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GpuTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGpuTypeValueUnknown(), diags
	}

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return NewGpuTypeValueUnknown(), diags
	}

	return GpuTypeValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GpuTypeValue {
	object, diags := NewGpuTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGpuTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GpuTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGpuTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGpuTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGpuTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGpuTypeValueMust(GpuTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GpuTypeType) ValueType(ctx context.Context) attr.Value {
	return GpuTypeValue{}
}

var _ basetypes.ObjectValuable = GpuTypeValue{}

type GpuTypeValue struct {
	CommunityPrice     basetypes.NumberValue `tfsdk:"community_price"`
	CommunitySpotPrice basetypes.NumberValue `tfsdk:"community_spot_price"`
	Count              basetypes.Int64Value  `tfsdk:"count"`
	DisplayName        basetypes.StringValue `tfsdk:"display_name"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	OneMonthPrice      basetypes.NumberValue `tfsdk:"one_month_price"`
	OneWeekPrice       basetypes.NumberValue `tfsdk:"one_week_price"`
	SecurePrice        basetypes.NumberValue `tfsdk:"secure_price"`
	SecureSpotPrice    basetypes.NumberValue `tfsdk:"secure_spot_price"`
	SixMonthPrice      basetypes.NumberValue `tfsdk:"six_month_price"`
	ThreeMonthPrice    basetypes.NumberValue `tfsdk:"three_month_price"`
	state              attr.ValueState
}

func (v GpuTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["community_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["community_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["one_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["one_week_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["six_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["three_month_price"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CommunityPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_price"] = val

		val, err = v.CommunitySpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_spot_price"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.OneMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_month_price"] = val

		val, err = v.OneWeekPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_week_price"] = val

		val, err = v.SecurePrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_price"] = val

		val, err = v.SecureSpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_spot_price"] = val

		val, err = v.SixMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["six_month_price"] = val

		val, err = v.ThreeMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["three_month_price"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GpuTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GpuTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GpuTypeValue) String() string {
	return "GpuTypeValue"
}

func (v GpuTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"community_price":      v.CommunityPrice,
			"community_spot_price": v.CommunitySpotPrice,
			"count":                v.Count,
			"display_name":         v.DisplayName,
			"id":                   v.Id,
			"one_month_price":      v.OneMonthPrice,
			"one_week_price":       v.OneWeekPrice,
			"secure_price":         v.SecurePrice,
			"secure_spot_price":    v.SecureSpotPrice,
			"six_month_price":      v.SixMonthPrice,
			"three_month_price":    v.ThreeMonthPrice,
		})

	return objVal, diags
}

func (v GpuTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(GpuTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommunityPrice.Equal(other.CommunityPrice) {
		return false
	}

	if !v.CommunitySpotPrice.Equal(other.CommunitySpotPrice) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.OneMonthPrice.Equal(other.OneMonthPrice) {
		return false
	}

	if !v.OneWeekPrice.Equal(other.OneWeekPrice) {
		return false
	}

	if !v.SecurePrice.Equal(other.SecurePrice) {
		return false
	}

	if !v.SecureSpotPrice.Equal(other.SecureSpotPrice) {
		return false
	}

	if !v.SixMonthPrice.Equal(other.SixMonthPrice) {
		return false
	}

	if !v.ThreeMonthPrice.Equal(other.ThreeMonthPrice) {
		return false
	}

	return true
}

func (v GpuTypeValue) Type(ctx context.Context) attr.Type {
	return GpuTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GpuTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = NetworkVolumeType{}

type NetworkVolumeType struct {
	basetypes.ObjectType
}

func (t NetworkVolumeType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkVolumeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkVolumeType) String() string {
	return "NetworkVolumeType"
}

func (t NetworkVolumeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return nil, diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkVolumeValue{
		DataCenterId: dataCenterIdVal,
		Id:           idVal,
		Name:         nameVal,
		Size:         sizeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetworkVolumeValueNull() NetworkVolumeValue {
	return NetworkVolumeValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkVolumeValueUnknown() NetworkVolumeValue {
	return NetworkVolumeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkVolumeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkVolumeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkVolumeValue Attribute Value",
				"While creating a NetworkVolumeValue value, a missing attribute value was detected. "+
					"A NetworkVolumeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkVolumeValue Attribute Type",
				"While creating a NetworkVolumeValue value, an invalid attribute value was detected. "+
					"A NetworkVolumeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkVolumeValue Attribute Value",
				"While creating a NetworkVolumeValue value, an extra attribute value was detected. "+
					"A NetworkVolumeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkVolumeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkVolumeValueUnknown(), diags
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewNetworkVolumeValueUnknown(), diags
	}

	return NetworkVolumeValue{
		DataCenterId: dataCenterIdVal,
		Id:           idVal,
		Name:         nameVal,
		Size:         sizeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetworkVolumeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkVolumeValue {
	object, diags := NewNetworkVolumeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkVolumeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkVolumeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkVolumeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkVolumeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkVolumeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkVolumeValueMust(NetworkVolumeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkVolumeType) ValueType(ctx context.Context) attr.Value {
	return NetworkVolumeValue{}
}

var _ basetypes.ObjectValuable = NetworkVolumeValue{}

type NetworkVolumeValue struct {
	DataCenterId basetypes.StringValue `tfsdk:"data_center_id"`
	Id           basetypes.StringValue `tfsdk:"id"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Size         basetypes.Int64Value  `tfsdk:"size"`
	state        attr.ValueState
}

func (v NetworkVolumeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["data_center_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DataCenterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_center_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkVolumeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkVolumeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkVolumeValue) String() string {
	return "NetworkVolumeValue"
}

func (v NetworkVolumeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"data_center_id": basetypes.StringType{},
		"id":             basetypes.StringType{},
		"name":           basetypes.StringType{},
		"size":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data_center_id": v.DataCenterId,
			"id":             v.Id,
			"name":           v.Name,
			"size":           v.Size,
		})

	return objVal, diags
}

func (v NetworkVolumeValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkVolumeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataCenterId.Equal(other.DataCenterId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v NetworkVolumeValue) Type(ctx context.Context) attr.Type {
	return NetworkVolumeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkVolumeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_center_id": basetypes.StringType{},
		"id":             basetypes.StringType{},
		"name":           basetypes.StringType{},
		"size":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortMappingsType{}

type PortMappingsType struct {
	basetypes.ObjectType
}

func (t PortMappingsType) Equal(o attr.Type) bool {
	other, ok := o.(PortMappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMappingsType) String() string {
	return "PortMappingsType"
}

func (t PortMappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return PortMappingsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewPortMappingsValueNull() PortMappingsValue {
	return PortMappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMappingsValueUnknown() PortMappingsValue {
	return PortMappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMappingsValue Attribute Value",
				"While creating a PortMappingsValue value, a missing attribute value was detected. "+
					"A PortMappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMappingsValue Attribute Type",
				"While creating a PortMappingsValue value, an invalid attribute value was detected. "+
					"A PortMappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMappingsValue Attribute Value",
				"While creating a PortMappingsValue value, an extra attribute value was detected. "+
					"A PortMappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMappingsValueUnknown(), diags
	}

	if diags.HasError() {
		return NewPortMappingsValueUnknown(), diags
	}

	return PortMappingsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewPortMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMappingsValue {
	object, diags := NewPortMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMappingsValueMust(PortMappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMappingsType) ValueType(ctx context.Context) attr.Value {
	return PortMappingsValue{}
}

var _ basetypes.ObjectValuable = PortMappingsValue{}

type PortMappingsValue struct {
	state attr.ValueState
}

func (v PortMappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMappingsValue) String() string {
	return "PortMappingsValue"
}

func (v PortMappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v PortMappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v PortMappingsValue) Type(ctx context.Context) attr.Type {
	return PortMappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = SavingsPlansType{}

type SavingsPlansType struct {
	basetypes.ObjectType
}

func (t SavingsPlansType) Equal(o attr.Type) bool {
	other, ok := o.(SavingsPlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SavingsPlansType) String() string {
	return "SavingsPlansType"
}

func (t SavingsPlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return nil, diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	endTimeAttribute, ok := attributes["end_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_time is missing from object`)

		return nil, diags
	}

	endTimeVal, ok := endTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_time expected to be basetypes.StringValue, was: %T`, endTimeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return nil, diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	podIdAttribute, ok := attributes["pod_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_id is missing from object`)

		return nil, diags
	}

	podIdVal, ok := podIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_id expected to be basetypes.StringValue, was: %T`, podIdAttribute))
	}

	startTimeAttribute, ok := attributes["start_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_time is missing from object`)

		return nil, diags
	}

	startTimeVal, ok := startTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_time expected to be basetypes.StringValue, was: %T`, startTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SavingsPlansValue{
		CostPerHr: costPerHrVal,
		EndTime:   endTimeVal,
		GpuTypeId: gpuTypeIdVal,
		Id:        idVal,
		PodId:     podIdVal,
		StartTime: startTimeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSavingsPlansValueNull() SavingsPlansValue {
	return SavingsPlansValue{
		state: attr.ValueStateNull,
	}
}

func NewSavingsPlansValueUnknown() SavingsPlansValue {
	return SavingsPlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSavingsPlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SavingsPlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SavingsPlansValue Attribute Value",
				"While creating a SavingsPlansValue value, a missing attribute value was detected. "+
					"A SavingsPlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SavingsPlansValue Attribute Type",
				"While creating a SavingsPlansValue value, an invalid attribute value was detected. "+
					"A SavingsPlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SavingsPlansValue Attribute Value",
				"While creating a SavingsPlansValue value, an extra attribute value was detected. "+
					"A SavingsPlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SavingsPlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSavingsPlansValueUnknown(), diags
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	endTimeAttribute, ok := attributes["end_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_time is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	endTimeVal, ok := endTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_time expected to be basetypes.StringValue, was: %T`, endTimeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	podIdAttribute, ok := attributes["pod_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	podIdVal, ok := podIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_id expected to be basetypes.StringValue, was: %T`, podIdAttribute))
	}

	startTimeAttribute, ok := attributes["start_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_time is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	startTimeVal, ok := startTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_time expected to be basetypes.StringValue, was: %T`, startTimeAttribute))
	}

	if diags.HasError() {
		return NewSavingsPlansValueUnknown(), diags
	}

	return SavingsPlansValue{
		CostPerHr: costPerHrVal,
		EndTime:   endTimeVal,
		GpuTypeId: gpuTypeIdVal,
		Id:        idVal,
		PodId:     podIdVal,
		StartTime: startTimeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSavingsPlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SavingsPlansValue {
	object, diags := NewSavingsPlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSavingsPlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SavingsPlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSavingsPlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSavingsPlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSavingsPlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSavingsPlansValueMust(SavingsPlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SavingsPlansType) ValueType(ctx context.Context) attr.Value {
	return SavingsPlansValue{}
}

var _ basetypes.ObjectValuable = SavingsPlansValue{}

type SavingsPlansValue struct {
	CostPerHr basetypes.NumberValue `tfsdk:"cost_per_hr"`
	EndTime   basetypes.StringValue `tfsdk:"end_time"`
	GpuTypeId basetypes.StringValue `tfsdk:"gpu_type_id"`
	Id        basetypes.StringValue `tfsdk:"id"`
	PodId     basetypes.StringValue `tfsdk:"pod_id"`
	StartTime basetypes.StringValue `tfsdk:"start_time"`
	state     attr.ValueState
}

func (v SavingsPlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["end_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.CostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost_per_hr"] = val

		val, err = v.EndTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end_time"] = val

		val, err = v.GpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.PodId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_id"] = val

		val, err = v.StartTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SavingsPlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SavingsPlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SavingsPlansValue) String() string {
	return "SavingsPlansValue"
}

func (v SavingsPlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"end_time":    basetypes.StringType{},
		"gpu_type_id": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"pod_id":      basetypes.StringType{},
		"start_time":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost_per_hr": v.CostPerHr,
			"end_time":    v.EndTime,
			"gpu_type_id": v.GpuTypeId,
			"id":          v.Id,
			"pod_id":      v.PodId,
			"start_time":  v.StartTime,
		})

	return objVal, diags
}

func (v SavingsPlansValue) Equal(o attr.Value) bool {
	other, ok := o.(SavingsPlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CostPerHr.Equal(other.CostPerHr) {
		return false
	}

	if !v.EndTime.Equal(other.EndTime) {
		return false
	}

	if !v.GpuTypeId.Equal(other.GpuTypeId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.PodId.Equal(other.PodId) {
		return false
	}

	if !v.StartTime.Equal(other.StartTime) {
		return false
	}

	return true
}

func (v SavingsPlansValue) Type(ctx context.Context) attr.Type {
	return SavingsPlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SavingsPlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"end_time":    basetypes.StringType{},
		"gpu_type_id": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"pod_id":      basetypes.StringType{},
		"start_time":  basetypes.StringType{},
	}
}
