// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_endpoint

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func EndpointResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allowed_cuda_versions": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Serverless endpoint is a GPU endpoint, a list of acceptable CUDA versions on the created workers. If not set, any CUDA version is acceptable.",
				MarkdownDescription: "If the created Serverless endpoint is a GPU endpoint, a list of acceptable CUDA versions on the created workers. If not set, any CUDA version is acceptable.",
			},
			"compute_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to GPU to create a Serverless endpoint with GPU workers. Set to CPU to create a Serverless endpoint with CPU workers. If set to CPU, properties related to GPUs such as gpuTypeIds will be ignored. If set to GPU, properties related to CPUs such as cpuFlavorIds will be ignored.",
				MarkdownDescription: "Set to GPU to create a Serverless endpoint with GPU workers. Set to CPU to create a Serverless endpoint with CPU workers. If set to CPU, properties related to GPUs such as gpuTypeIds will be ignored. If set to GPU, properties related to CPUs such as cpuFlavorIds will be ignored.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"GPU",
						"CPU",
					),
				},
				Default: stringdefault.StaticString("GPU"),
			},
			"cpu_flavor_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Serverless endpoint is a CPU endpoint, a list of RunPod CPU flavors which can be attached to the created workers. The order of the list determines the order to rent CPU flavors.",
				MarkdownDescription: "If the created Serverless endpoint is a CPU endpoint, a list of RunPod CPU flavors which can be attached to the created workers. The order of the list determines the order to rent CPU flavors.",
			},
			"created_at": schema.StringAttribute{
				Computed:            true,
				Description:         "The UTC timestamp when a Serverless endpoint was created.",
				MarkdownDescription: "The UTC timestamp when a Serverless endpoint was created.",
			},
			"data_center_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "A list of RunPod data center IDs where workers on the created Serverless endpoint can be located.",
				MarkdownDescription: "A list of RunPod data center IDs where workers on the created Serverless endpoint can be located.",
			},
			"endpoint_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of endpoint to return.",
				MarkdownDescription: "ID of endpoint to return.",
			},
			"env": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: EnvType{
					ObjectType: types.ObjectType{
						AttrTypes: EnvValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"execution_timeout_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The maximum number of milliseconds an individual request can run on a Serverless endpoint before the worker is stopped and the request is marked as failed.",
				MarkdownDescription: "The maximum number of milliseconds an individual request can run on a Serverless endpoint before the worker is stopped and the request is marked as failed.",
			},
			"flashboot": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to use flash boot for the created Serverless endpoint.",
				MarkdownDescription: "Whether to use flash boot for the created Serverless endpoint.",
			},
			"gpu_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Serverless endpoint is a GPU endpoint, the number of GPUs attached to each worker on the endpoint.",
				MarkdownDescription: "If the created Serverless endpoint is a GPU endpoint, the number of GPUs attached to each worker on the endpoint.",
				Validators: []validator.Int64{
					int64validator.AtLeast(1),
				},
				Default: int64default.StaticInt64(1),
			},
			"gpu_type_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "If the created Serverless endpoint is a GPU endpoint, a list of RunPod GPU types which can be attached to the created workers. The order of the list determines the order to rent GPU types.",
				MarkdownDescription: "If the created Serverless endpoint is a GPU endpoint, a list of RunPod GPU types which can be attached to the created workers. The order of the list determines the order to rent GPU types.",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "A unique string identifying a Serverless endpoint.",
				MarkdownDescription: "A unique string identifying a Serverless endpoint.",
			},
			"idle_timeout": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The number of seconds a worker on the created Serverless endpoint can run without taking a job before the worker is scaled down.",
				MarkdownDescription: "The number of seconds a worker on the created Serverless endpoint can run without taking a job before the worker is scaled down.",
				Validators: []validator.Int64{
					int64validator.Between(1, 3600),
				},
				Default: int64default.StaticInt64(5),
			},
			"include_template": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the template used to create the endpoint.",
				MarkdownDescription: "Include information about the template used to create the endpoint.",
				Default:             booldefault.StaticBool(false),
			},
			"include_workers": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Include information about the workers running on the endpoint.",
				MarkdownDescription: "Include information about the workers running on the endpoint.",
				Default:             booldefault.StaticBool(false),
			},
			"instance_ids": schema.ListAttribute{
				ElementType:         types.StringType,
				Computed:            true,
				Description:         "For CPU Serverless endpoints, a list of instance IDs that can be attached to a Serverless endpoint.",
				MarkdownDescription: "For CPU Serverless endpoints, a list of instance IDs that can be attached to a Serverless endpoint.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A user-defined name for the created Serverless endpoint. The name does not need to be unique.",
				MarkdownDescription: "A user-defined name for the created Serverless endpoint. The name does not need to be unique.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(191),
				},
			},
			"network_volume_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The unique string identifying the network volume to attach to the created Serverless endpoint.",
				MarkdownDescription: "The unique string identifying the network volume to attach to the created Serverless endpoint.",
			},
			"scaler_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The method used to scale up workers on the created Serverless endpoint. If QUEUE_DELAY, workers are scaled based on a periodic check to see if any requests have been in queue for too long. If REQUEST_COUNT, the desired number of workers is periodically calculated based on the number of requests in the endpoint's queue. Use QUEUE_DELAY if you need to ensure requests take no longer than a maximum latency, and use REQUEST_COUNT if you need to scale based on the number of requests.",
				MarkdownDescription: "The method used to scale up workers on the created Serverless endpoint. If QUEUE_DELAY, workers are scaled based on a periodic check to see if any requests have been in queue for too long. If REQUEST_COUNT, the desired number of workers is periodically calculated based on the number of requests in the endpoint's queue. Use QUEUE_DELAY if you need to ensure requests take no longer than a maximum latency, and use REQUEST_COUNT if you need to scale based on the number of requests.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"QUEUE_DELAY",
						"REQUEST_COUNT",
					),
				},
				Default: stringdefault.StaticString("QUEUE_DELAY"),
			},
			"scaler_value": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the endpoint scalerType is QUEUE_DELAY, the number of seconds a request can remain in queue before a new worker is scaled up. If the endpoint scalerType is REQUEST_COUNT, the number of workers is increased as needed to meet the number of requests in the endpoint's queue divided by scalerValue.",
				MarkdownDescription: "If the endpoint scalerType is QUEUE_DELAY, the number of seconds a request can remain in queue before a new worker is scaled up. If the endpoint scalerType is REQUEST_COUNT, the number of workers is increased as needed to meet the number of requests in the endpoint's queue divided by scalerValue.",
				Validators: []validator.Int64{
					int64validator.AtLeast(1),
				},
				Default: int64default.StaticInt64(4),
			},
			"template": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"category": schema.StringAttribute{
						Computed:            true,
						Description:         "The category of the template. The category can be used to filter templates in the RunPod UI. Current categories are NVIDIA, AMD, and CPU.",
						MarkdownDescription: "The category of the template. The category can be used to filter templates in the RunPod UI. Current categories are NVIDIA, AMD, and CPU.",
					},
					"container_disk_in_gb": schema.Int64Attribute{
						Computed:            true,
						Description:         "The amount of disk space, in gigabytes (GB), to allocate on the container disk for a Pod or worker. The data on the container disk is wiped when the Pod or worker restarts. To persist data across restarts, set volumeInGb to configure the local network volume.",
						MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the container disk for a Pod or worker. The data on the container disk is wiped when the Pod or worker restarts. To persist data across restarts, set volumeInGb to configure the local network volume.",
					},
					"container_registry_auth_id": schema.StringAttribute{
						Computed: true,
					},
					"docker_entrypoint": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "If specified, overrides the ENTRYPOINT for the Docker image run on a Pod or worker. If [], uses the ENTRYPOINT defined in the image.",
						MarkdownDescription: "If specified, overrides the ENTRYPOINT for the Docker image run on a Pod or worker. If [], uses the ENTRYPOINT defined in the image.",
					},
					"docker_start_cmd": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "If specified, overrides the start CMD for the Docker image run on a Pod or worker. If [], uses the start CMD defined in the image.",
						MarkdownDescription: "If specified, overrides the start CMD for the Docker image run on a Pod or worker. If [], uses the start CMD defined in the image.",
					},
					"earned": schema.NumberAttribute{
						Computed:            true,
						Description:         "The amount of RunPod credits earned by the creator of a template by all Pods or workers created from the template.",
						MarkdownDescription: "The amount of RunPod credits earned by the creator of a template by all Pods or workers created from the template.",
					},
					"env": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{},
						CustomType: EnvType{
							ObjectType: types.ObjectType{
								AttrTypes: EnvValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.StringAttribute{
						Computed:            true,
						Description:         "A unique string identifying a template.",
						MarkdownDescription: "A unique string identifying a template.",
					},
					"image_name": schema.StringAttribute{
						Computed:            true,
						Description:         "The image tag for the container run on Pods or workers created from a template.",
						MarkdownDescription: "The image tag for the container run on Pods or workers created from a template.",
					},
					"is_public": schema.BoolAttribute{
						Computed:            true,
						Description:         "Set to true if a template is public and can be used by any RunPod user. Set to false if a template is private and can only be used by the creator.",
						MarkdownDescription: "Set to true if a template is public and can be used by any RunPod user. Set to false if a template is private and can only be used by the creator.",
					},
					"is_runpod": schema.BoolAttribute{
						Computed:            true,
						Description:         "If true, a template is an official template managed by RunPod.",
						MarkdownDescription: "If true, a template is an official template managed by RunPod.",
					},
					"is_serverless": schema.BoolAttribute{
						Computed:            true,
						Description:         "If true, instances created from a template are Serverless workers. If false, instances created from a template are Pods.",
						MarkdownDescription: "If true, instances created from a template are Serverless workers. If false, instances created from a template are Pods.",
					},
					"name": schema.StringAttribute{
						Computed:            true,
						Description:         "A user-defined name for a template. The name needs to be unique.",
						MarkdownDescription: "A user-defined name for a template. The name needs to be unique.",
					},
					"ports": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "A list of ports exposed on a Pod or worker. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
						MarkdownDescription: "A list of ports exposed on a Pod or worker. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
					},
					"readme": schema.StringAttribute{
						Computed:            true,
						Description:         "A string of markdown-formatted text that describes a template. The readme is displayed in the RunPod UI when a user selects the template.",
						MarkdownDescription: "A string of markdown-formatted text that describes a template. The readme is displayed in the RunPod UI when a user selects the template.",
					},
					"runtime_in_min": schema.Int64Attribute{
						Computed: true,
					},
					"volume_in_gb": schema.Int64Attribute{
						Computed:            true,
						Description:         "The amount of disk space, in gigabytes (GB), to allocate on the local network volume for a Pod or worker. The data on the local network volume is persisted across restarts. To persist data so that future Pods and workers can access it, create a network volume and set networkVolumeId to attach it to the Pod or worker.",
						MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the local network volume for a Pod or worker. The data on the local network volume is persisted across restarts. To persist data so that future Pods and workers can access it, create a network volume and set networkVolumeId to attach it to the Pod or worker.",
					},
					"volume_mount_path": schema.StringAttribute{
						Computed:            true,
						Description:         "If a local network volume or network volume is attached to a Pod or worker, the absolute path where the network volume is mounted in the filesystem.",
						MarkdownDescription: "If a local network volume or network volume is attached to a Pod or worker, the absolute path where the network volume is mounted in the filesystem.",
					},
				},
				CustomType: TemplateType{
					ObjectType: types.ObjectType{
						AttrTypes: TemplateValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"template_id": schema.StringAttribute{
				Required:            true,
				Description:         "The unique string identifying the template used to create the Serverless endpoint.",
				MarkdownDescription: "The unique string identifying the template used to create the Serverless endpoint.",
			},
			"user_id": schema.StringAttribute{
				Computed:            true,
				Description:         "A unique string identifying the RunPod user who created a Serverless endpoint.",
				MarkdownDescription: "A unique string identifying the RunPod user who created a Serverless endpoint.",
			},
			"vcpu_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If the created Serverless endpoint is a CPU endpoint, the number of vCPUs allocated to each created worker.",
				MarkdownDescription: "If the created Serverless endpoint is a CPU endpoint, the number of vCPUs allocated to each created worker.",
				Default:             int64default.StaticInt64(2),
			},
			"version": schema.Int64Attribute{
				Computed:            true,
				Description:         "The latest version of a Serverless endpoint, which is updated whenever the template or environment variables of the endpoint are changed.",
				MarkdownDescription: "The latest version of a Serverless endpoint, which is updated whenever the template or environment variables of the endpoint are changed.",
			},
			"workers": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"adjusted_cost_per_hr": schema.NumberAttribute{
							Computed:            true,
							Description:         "The effective cost in RunPod credits per hour of running a Pod, adjusted by active Savings Plans.",
							MarkdownDescription: "The effective cost in RunPod credits per hour of running a Pod, adjusted by active Savings Plans.",
						},
						"ai_api_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Synonym for endpointId (legacy name).",
							MarkdownDescription: "Synonym for endpointId (legacy name).",
						},
						"consumer_user_id": schema.StringAttribute{
							Computed:            true,
							Description:         "A unique string identifying the RunPod user who rents a Pod.",
							MarkdownDescription: "A unique string identifying the RunPod user who rents a Pod.",
						},
						"container_disk_in_gb": schema.Int64Attribute{
							Computed:            true,
							Description:         "The amount of disk space, in gigabytes (GB), to allocate on the container disk for a Pod. The data on the container disk is wiped when the Pod restarts. To persist data across Pod restarts, set volumeInGb to configure the Pod network volume.",
							MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the container disk for a Pod. The data on the container disk is wiped when the Pod restarts. To persist data across Pod restarts, set volumeInGb to configure the Pod network volume.",
						},
						"container_registry_auth_id": schema.StringAttribute{
							Computed:            true,
							Description:         "If a Pod is created with a container registry auth, the unique string identifying that container registry auth.",
							MarkdownDescription: "If a Pod is created with a container registry auth, the unique string identifying that container registry auth.",
						},
						"cost_per_hr": schema.NumberAttribute{
							Computed:            true,
							Description:         "The cost in RunPod credits per hour of running a Pod. Note that the actual cost may be lower if Savings Plans are applied.",
							MarkdownDescription: "The cost in RunPod credits per hour of running a Pod. Note that the actual cost may be lower if Savings Plans are applied.",
						},
						"cpu_flavor_id": schema.StringAttribute{
							Computed:            true,
							Description:         "If the Pod is a CPU Pod, the unique string identifying the CPU flavor the Pod is running on.",
							MarkdownDescription: "If the Pod is a CPU Pod, the unique string identifying the CPU flavor the Pod is running on.",
						},
						"desired_status": schema.StringAttribute{
							Computed:            true,
							Description:         "The current expected status of a Pod.",
							MarkdownDescription: "The current expected status of a Pod.",
						},
						"docker_entrypoint": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "If specified, overrides the ENTRYPOINT for the Docker image run on the created Pod. If [], uses the ENTRYPOINT defined in the image.",
							MarkdownDescription: "If specified, overrides the ENTRYPOINT for the Docker image run on the created Pod. If [], uses the ENTRYPOINT defined in the image.",
						},
						"docker_start_cmd": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "If specified, overrides the start CMD for the Docker image run on the created Pod. If [], uses the start CMD defined in the image.",
							MarkdownDescription: "If specified, overrides the start CMD for the Docker image run on the created Pod. If [], uses the start CMD defined in the image.",
						},
						"endpoint_id": schema.StringAttribute{
							Computed:            true,
							Description:         "If the Pod is a Serverless worker, a unique string identifying the associated endpoint.",
							MarkdownDescription: "If the Pod is a Serverless worker, a unique string identifying the associated endpoint.",
						},
						"env": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{},
							CustomType: EnvType{
								ObjectType: types.ObjectType{
									AttrTypes: EnvValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"gpu": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"community_price": schema.NumberAttribute{
									Computed: true,
								},
								"community_spot_price": schema.NumberAttribute{
									Computed: true,
								},
								"count": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of GPUs attached to a Pod.",
									MarkdownDescription: "The number of GPUs attached to a Pod.",
								},
								"display_name": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"one_month_price": schema.NumberAttribute{
									Computed: true,
								},
								"one_week_price": schema.NumberAttribute{
									Computed: true,
								},
								"secure_price": schema.NumberAttribute{
									Computed: true,
								},
								"secure_spot_price": schema.NumberAttribute{
									Computed: true,
								},
								"six_month_price": schema.NumberAttribute{
									Computed: true,
								},
								"three_month_price": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: GpuType{
								ObjectType: types.ObjectType{
									AttrTypes: GpuValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "A unique string identifying a [Pod](#/components/schema/Pod).",
							MarkdownDescription: "A unique string identifying a [Pod](#/components/schema/Pod).",
						},
						"image": schema.StringAttribute{
							Computed:            true,
							Description:         "The image tag for the container run on a Pod.",
							MarkdownDescription: "The image tag for the container run on a Pod.",
						},
						"interruptible": schema.BoolAttribute{
							Computed:            true,
							Description:         "Describes how a Pod is rented. An interruptible Pod can be rented at a lower cost but can be stopped at any time to free up resources for another Pod. A reserved Pod is rented at a higher cost but runs until it exits or is manually stopped.",
							MarkdownDescription: "Describes how a Pod is rented. An interruptible Pod can be rented at a lower cost but can be stopped at any time to free up resources for another Pod. A reserved Pod is rented at a higher cost but runs until it exits or is manually stopped.",
						},
						"last_started_at": schema.StringAttribute{
							Computed:            true,
							Description:         "The UTC timestamp when a Pod was last started.",
							MarkdownDescription: "The UTC timestamp when a Pod was last started.",
						},
						"last_status_change": schema.StringAttribute{
							Computed:            true,
							Description:         "A string describing the last lifecycle event on a Pod.",
							MarkdownDescription: "A string describing the last lifecycle event on a Pod.",
						},
						"locked": schema.BoolAttribute{
							Computed:            true,
							Description:         "Set to true to lock a Pod. Locking a Pod disables stopping or resetting the Pod.",
							MarkdownDescription: "Set to true to lock a Pod. Locking a Pod disables stopping or resetting the Pod.",
						},
						"machine": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"cost_per_hr": schema.NumberAttribute{
									Computed: true,
								},
								"cpu_count": schema.Int64Attribute{
									Computed: true,
								},
								"cpu_type": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"cores": schema.NumberAttribute{
											Computed: true,
										},
										"display_name": schema.StringAttribute{
											Computed: true,
										},
										"group_id": schema.StringAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"threads_per_core": schema.NumberAttribute{
											Computed: true,
										},
									},
									CustomType: CpuTypeType{
										ObjectType: types.ObjectType{
											AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"cpu_type_id": schema.StringAttribute{
									Computed: true,
								},
								"current_price_per_gpu": schema.NumberAttribute{
									Computed: true,
								},
								"data_center_id": schema.StringAttribute{
									Computed: true,
								},
								"disk_throughput_mbps": schema.Int64Attribute{
									Computed: true,
								},
								"gpu_available": schema.Int64Attribute{
									Computed: true,
								},
								"gpu_display_name": schema.StringAttribute{
									Computed: true,
								},
								"gpu_type": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"community_price": schema.NumberAttribute{
											Computed: true,
										},
										"community_spot_price": schema.NumberAttribute{
											Computed: true,
										},
										"count": schema.Int64Attribute{
											Computed:            true,
											Description:         "The number of GPUs attached to a Pod.",
											MarkdownDescription: "The number of GPUs attached to a Pod.",
										},
										"display_name": schema.StringAttribute{
											Computed: true,
										},
										"id": schema.StringAttribute{
											Computed: true,
										},
										"one_month_price": schema.NumberAttribute{
											Computed: true,
										},
										"one_week_price": schema.NumberAttribute{
											Computed: true,
										},
										"secure_price": schema.NumberAttribute{
											Computed: true,
										},
										"secure_spot_price": schema.NumberAttribute{
											Computed: true,
										},
										"six_month_price": schema.NumberAttribute{
											Computed: true,
										},
										"three_month_price": schema.NumberAttribute{
											Computed: true,
										},
									},
									CustomType: GpuTypeType{
										ObjectType: types.ObjectType{
											AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"gpu_type_id": schema.StringAttribute{
									Computed: true,
								},
								"location": schema.StringAttribute{
									Computed: true,
								},
								"maintenance_end": schema.StringAttribute{
									Computed: true,
								},
								"maintenance_note": schema.StringAttribute{
									Computed: true,
								},
								"maintenance_start": schema.StringAttribute{
									Computed: true,
								},
								"max_download_speed_mbps": schema.Int64Attribute{
									Computed: true,
								},
								"max_upload_speed_mbps": schema.Int64Attribute{
									Computed: true,
								},
								"min_pod_gpu_count": schema.Int64Attribute{
									Computed: true,
								},
								"note": schema.StringAttribute{
									Computed: true,
								},
								"secure_cloud": schema.BoolAttribute{
									Computed: true,
								},
								"support_public_ip": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: MachineType{
								ObjectType: types.ObjectType{
									AttrTypes: MachineValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Information about the machine a Pod is running on (see [Machine](#/components/schemas/Machine)).",
							MarkdownDescription: "Information about the machine a Pod is running on (see [Machine](#/components/schemas/Machine)).",
						},
						"machine_id": schema.StringAttribute{
							Computed:            true,
							Description:         "A unique string identifying the host machine a Pod is running on.",
							MarkdownDescription: "A unique string identifying the host machine a Pod is running on.",
						},
						"memory_in_gb": schema.NumberAttribute{
							Computed:            true,
							Description:         "The amount of RAM, in gigabytes (GB), attached to a Pod.",
							MarkdownDescription: "The amount of RAM, in gigabytes (GB), attached to a Pod.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "A user-defined name for the created Pod. The name does not need to be unique.",
							MarkdownDescription: "A user-defined name for the created Pod. The name does not need to be unique.",
						},
						"network_volume": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"data_center_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The RunPod data center ID where a network volume is located.",
									MarkdownDescription: "The RunPod data center ID where a network volume is located.",
								},
								"id": schema.StringAttribute{
									Computed:            true,
									Description:         "A unique string identifying a network volume.",
									MarkdownDescription: "A unique string identifying a network volume.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "A user-defined name for a network volume. The name does not need to be unique.",
									MarkdownDescription: "A user-defined name for a network volume. The name does not need to be unique.",
								},
								"size": schema.Int64Attribute{
									Computed:            true,
									Description:         "The amount of disk space, in gigabytes (GB), allocated to a network volume.",
									MarkdownDescription: "The amount of disk space, in gigabytes (GB), allocated to a network volume.",
								},
							},
							CustomType: NetworkVolumeType{
								ObjectType: types.ObjectType{
									AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "If a network volume is attached to a Pod, information about the network volume (see [network volume schema](#/components/schemas/NetworkVolume)).",
							MarkdownDescription: "If a network volume is attached to a Pod, information about the network volume (see [network volume schema](#/components/schemas/NetworkVolume)).",
						},
						"port_mappings": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{},
							CustomType: PortMappingsType{
								ObjectType: types.ObjectType{
									AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "A mapping of internal ports to public ports on a Pod. For example, { \"22\": 10341 } means that port 22 on the Pod is mapped to port 10341 and is publicly accessible at [public ip]:10341. If the Pod is still initializing, this mapping is not yet determined and will be empty.",
							MarkdownDescription: "A mapping of internal ports to public ports on a Pod. For example, { \"22\": 10341 } means that port 22 on the Pod is mapped to port 10341 and is publicly accessible at [public ip]:10341. If the Pod is still initializing, this mapping is not yet determined and will be empty.",
						},
						"ports": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "A list of ports exposed on a Pod. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
							MarkdownDescription: "A list of ports exposed on a Pod. Each port is formatted as [port number]/[protocol]. Protocol can be either http or tcp.",
						},
						"public_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "The public IP address of a Pod. If the Pod is still initializing, this IP is not yet determined and will be empty.",
							MarkdownDescription: "The public IP address of a Pod. If the Pod is still initializing, this IP is not yet determined and will be empty.",
						},
						"savings_plans": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"cost_per_hr": schema.NumberAttribute{
										Computed: true,
									},
									"end_time": schema.StringAttribute{
										Computed: true,
									},
									"gpu_type_id": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.StringAttribute{
										Computed: true,
									},
									"pod_id": schema.StringAttribute{
										Computed: true,
									},
									"start_time": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SavingsPlansType{
									ObjectType: types.ObjectType{
										AttrTypes: SavingsPlansValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "The list of active Savings Plans applied to a Pod (see [Savings Plans](#/components/schemas/SavingsPlan)). If none are applied, the list is empty.",
							MarkdownDescription: "The list of active Savings Plans applied to a Pod (see [Savings Plans](#/components/schemas/SavingsPlan)). If none are applied, the list is empty.",
						},
						"sls_version": schema.Int64Attribute{
							Computed:            true,
							Description:         "If the Pod is a Serverless worker, the version of the associated endpoint (see [Endpoint Version](#/components/schemas/Endpoint/version)).",
							MarkdownDescription: "If the Pod is a Serverless worker, the version of the associated endpoint (see [Endpoint Version](#/components/schemas/Endpoint/version)).",
						},
						"template_id": schema.StringAttribute{
							Computed:            true,
							Description:         "If a Pod is created with a template, the unique string identifying that template.",
							MarkdownDescription: "If a Pod is created with a template, the unique string identifying that template.",
						},
						"vcpu_count": schema.NumberAttribute{
							Computed:            true,
							Description:         "The number of virtual CPUs attached to a Pod.",
							MarkdownDescription: "The number of virtual CPUs attached to a Pod.",
						},
						"volume_encrypted": schema.BoolAttribute{
							Computed:            true,
							Description:         "Set to true if the local network volume of a Pod is encrypted. Can only be set when creating a Pod.",
							MarkdownDescription: "Set to true if the local network volume of a Pod is encrypted. Can only be set when creating a Pod.",
						},
						"volume_in_gb": schema.Int64Attribute{
							Computed:            true,
							Description:         "The amount of disk space, in gigabytes (GB), to allocate on the Pod volume for a Pod. The data on the Pod volume is persisted across Pod restarts. To persist data so that future Pods can access it, create a network volume and set networkVolumeId to attach it to the Pod.",
							MarkdownDescription: "The amount of disk space, in gigabytes (GB), to allocate on the Pod volume for a Pod. The data on the Pod volume is persisted across Pod restarts. To persist data so that future Pods can access it, create a network volume and set networkVolumeId to attach it to the Pod.",
						},
						"volume_mount_path": schema.StringAttribute{
							Computed:            true,
							Description:         "If either a Pod volume or a network volume is attached to a Pod, the absolute path where the network volume is mounted in the filesystem.",
							MarkdownDescription: "If either a Pod volume or a network volume is attached to a Pod, the absolute path where the network volume is mounted in the filesystem.",
						},
					},
					CustomType: WorkersType{
						ObjectType: types.ObjectType{
							AttrTypes: WorkersValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Information about current workers on a Serverless endpoint.",
				MarkdownDescription: "Information about current workers on a Serverless endpoint.",
			},
			"workers_max": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The maximum number of workers that can be running at the same time on a Serverless endpoint.",
				MarkdownDescription: "The maximum number of workers that can be running at the same time on a Serverless endpoint.",
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
			"workers_min": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum number of workers that will run at the same time on a Serverless endpoint. This number of workers will always stay running for the endpoint, and will be charged even if no requests are being processed, but they are charged at a lower rate than running autoscaling workers.",
				MarkdownDescription: "The minimum number of workers that will run at the same time on a Serverless endpoint. This number of workers will always stay running for the endpoint, and will be charged even if no requests are being processed, but they are charged at a lower rate than running autoscaling workers.",
				Validators: []validator.Int64{
					int64validator.AtLeast(0),
				},
			},
		},
	}
}

type EndpointModel struct {
	AllowedCudaVersions types.List    `tfsdk:"allowed_cuda_versions"`
	ComputeType         types.String  `tfsdk:"compute_type"`
	CpuFlavorIds        types.List    `tfsdk:"cpu_flavor_ids"`
	CreatedAt           types.String  `tfsdk:"created_at"`
	DataCenterIds       types.List    `tfsdk:"data_center_ids"`
	EndpointId          types.String  `tfsdk:"endpoint_id"`
	Env                 EnvValue      `tfsdk:"env"`
	ExecutionTimeoutMs  types.Int64   `tfsdk:"execution_timeout_ms"`
	Flashboot           types.Bool    `tfsdk:"flashboot"`
	GpuCount            types.Int64   `tfsdk:"gpu_count"`
	GpuTypeIds          types.List    `tfsdk:"gpu_type_ids"`
	Id                  types.String  `tfsdk:"id"`
	IdleTimeout         types.Int64   `tfsdk:"idle_timeout"`
	IncludeTemplate     types.Bool    `tfsdk:"include_template"`
	IncludeWorkers      types.Bool    `tfsdk:"include_workers"`
	InstanceIds         types.List    `tfsdk:"instance_ids"`
	Name                types.String  `tfsdk:"name"`
	NetworkVolumeId     types.String  `tfsdk:"network_volume_id"`
	ScalerType          types.String  `tfsdk:"scaler_type"`
	ScalerValue         types.Int64   `tfsdk:"scaler_value"`
	Template            TemplateValue `tfsdk:"template"`
	TemplateId          types.String  `tfsdk:"template_id"`
	UserId              types.String  `tfsdk:"user_id"`
	VcpuCount           types.Int64   `tfsdk:"vcpu_count"`
	Version             types.Int64   `tfsdk:"version"`
	Workers             types.List    `tfsdk:"workers"`
	WorkersMax          types.Int64   `tfsdk:"workers_max"`
	WorkersMin          types.Int64   `tfsdk:"workers_min"`
}

var _ basetypes.ObjectTypable = EnvType{}

type EnvType struct {
	basetypes.ObjectType
}

func (t EnvType) Equal(o attr.Type) bool {
	other, ok := o.(EnvType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvType) String() string {
	return "EnvType"
}

func (t EnvType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return EnvValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvValueNull() EnvValue {
	return EnvValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvValueUnknown() EnvValue {
	return EnvValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvValue Attribute Value",
				"While creating a EnvValue value, a missing attribute value was detected. "+
					"A EnvValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvValue Attribute Type",
				"While creating a EnvValue value, an invalid attribute value was detected. "+
					"A EnvValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvValue Attribute Value",
				"While creating a EnvValue value, an extra attribute value was detected. "+
					"A EnvValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvValueUnknown(), diags
	}

	if diags.HasError() {
		return NewEnvValueUnknown(), diags
	}

	return EnvValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvValue {
	object, diags := NewEnvValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvValueMust(EnvValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvType) ValueType(ctx context.Context) attr.Value {
	return EnvValue{}
}

var _ basetypes.ObjectValuable = EnvValue{}

type EnvValue struct {
	state attr.ValueState
}

func (v EnvValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvValue) String() string {
	return "EnvValue"
}

func (v EnvValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v EnvValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v EnvValue) Type(ctx context.Context) attr.Type {
	return EnvType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = TemplateType{}

type TemplateType struct {
	basetypes.ObjectType
}

func (t TemplateType) Equal(o attr.Type) bool {
	other, ok := o.(TemplateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TemplateType) String() string {
	return "TemplateType"
}

func (t TemplateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return nil, diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	containerDiskInGbAttribute, ok := attributes["container_disk_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_disk_in_gb is missing from object`)

		return nil, diags
	}

	containerDiskInGbVal, ok := containerDiskInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_disk_in_gb expected to be basetypes.Int64Value, was: %T`, containerDiskInGbAttribute))
	}

	containerRegistryAuthIdAttribute, ok := attributes["container_registry_auth_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_registry_auth_id is missing from object`)

		return nil, diags
	}

	containerRegistryAuthIdVal, ok := containerRegistryAuthIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_registry_auth_id expected to be basetypes.StringValue, was: %T`, containerRegistryAuthIdAttribute))
	}

	dockerEntrypointAttribute, ok := attributes["docker_entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_entrypoint is missing from object`)

		return nil, diags
	}

	dockerEntrypointVal, ok := dockerEntrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_entrypoint expected to be basetypes.ListValue, was: %T`, dockerEntrypointAttribute))
	}

	dockerStartCmdAttribute, ok := attributes["docker_start_cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_start_cmd is missing from object`)

		return nil, diags
	}

	dockerStartCmdVal, ok := dockerStartCmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_start_cmd expected to be basetypes.ListValue, was: %T`, dockerStartCmdAttribute))
	}

	earnedAttribute, ok := attributes["earned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`earned is missing from object`)

		return nil, diags
	}

	earnedVal, ok := earnedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`earned expected to be basetypes.NumberValue, was: %T`, earnedAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return nil, diags
	}

	envVal, ok := envAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ObjectValue, was: %T`, envAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageNameAttribute, ok := attributes["image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_name is missing from object`)

		return nil, diags
	}

	imageNameVal, ok := imageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_name expected to be basetypes.StringValue, was: %T`, imageNameAttribute))
	}

	isPublicAttribute, ok := attributes["is_public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_public is missing from object`)

		return nil, diags
	}

	isPublicVal, ok := isPublicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_public expected to be basetypes.BoolValue, was: %T`, isPublicAttribute))
	}

	isRunpodAttribute, ok := attributes["is_runpod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_runpod is missing from object`)

		return nil, diags
	}

	isRunpodVal, ok := isRunpodAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_runpod expected to be basetypes.BoolValue, was: %T`, isRunpodAttribute))
	}

	isServerlessAttribute, ok := attributes["is_serverless"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_serverless is missing from object`)

		return nil, diags
	}

	isServerlessVal, ok := isServerlessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_serverless expected to be basetypes.BoolValue, was: %T`, isServerlessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	readmeAttribute, ok := attributes["readme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`readme is missing from object`)

		return nil, diags
	}

	readmeVal, ok := readmeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`readme expected to be basetypes.StringValue, was: %T`, readmeAttribute))
	}

	runtimeInMinAttribute, ok := attributes["runtime_in_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`runtime_in_min is missing from object`)

		return nil, diags
	}

	runtimeInMinVal, ok := runtimeInMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`runtime_in_min expected to be basetypes.Int64Value, was: %T`, runtimeInMinAttribute))
	}

	volumeInGbAttribute, ok := attributes["volume_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_in_gb is missing from object`)

		return nil, diags
	}

	volumeInGbVal, ok := volumeInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_in_gb expected to be basetypes.Int64Value, was: %T`, volumeInGbAttribute))
	}

	volumeMountPathAttribute, ok := attributes["volume_mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_mount_path is missing from object`)

		return nil, diags
	}

	volumeMountPathVal, ok := volumeMountPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_mount_path expected to be basetypes.StringValue, was: %T`, volumeMountPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TemplateValue{
		Category:                categoryVal,
		ContainerDiskInGb:       containerDiskInGbVal,
		ContainerRegistryAuthId: containerRegistryAuthIdVal,
		DockerEntrypoint:        dockerEntrypointVal,
		DockerStartCmd:          dockerStartCmdVal,
		Earned:                  earnedVal,
		Env:                     envVal,
		Id:                      idVal,
		ImageName:               imageNameVal,
		IsPublic:                isPublicVal,
		IsRunpod:                isRunpodVal,
		IsServerless:            isServerlessVal,
		Name:                    nameVal,
		Ports:                   portsVal,
		Readme:                  readmeVal,
		RuntimeInMin:            runtimeInMinVal,
		VolumeInGb:              volumeInGbVal,
		VolumeMountPath:         volumeMountPathVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewTemplateValueNull() TemplateValue {
	return TemplateValue{
		state: attr.ValueStateNull,
	}
}

func NewTemplateValueUnknown() TemplateValue {
	return TemplateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTemplateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TemplateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TemplateValue Attribute Value",
				"While creating a TemplateValue value, a missing attribute value was detected. "+
					"A TemplateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TemplateValue Attribute Type",
				"While creating a TemplateValue value, an invalid attribute value was detected. "+
					"A TemplateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TemplateValue Attribute Value",
				"While creating a TemplateValue value, an extra attribute value was detected. "+
					"A TemplateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TemplateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTemplateValueUnknown(), diags
	}

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	containerDiskInGbAttribute, ok := attributes["container_disk_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_disk_in_gb is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	containerDiskInGbVal, ok := containerDiskInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_disk_in_gb expected to be basetypes.Int64Value, was: %T`, containerDiskInGbAttribute))
	}

	containerRegistryAuthIdAttribute, ok := attributes["container_registry_auth_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_registry_auth_id is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	containerRegistryAuthIdVal, ok := containerRegistryAuthIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_registry_auth_id expected to be basetypes.StringValue, was: %T`, containerRegistryAuthIdAttribute))
	}

	dockerEntrypointAttribute, ok := attributes["docker_entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_entrypoint is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	dockerEntrypointVal, ok := dockerEntrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_entrypoint expected to be basetypes.ListValue, was: %T`, dockerEntrypointAttribute))
	}

	dockerStartCmdAttribute, ok := attributes["docker_start_cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_start_cmd is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	dockerStartCmdVal, ok := dockerStartCmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_start_cmd expected to be basetypes.ListValue, was: %T`, dockerStartCmdAttribute))
	}

	earnedAttribute, ok := attributes["earned"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`earned is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	earnedVal, ok := earnedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`earned expected to be basetypes.NumberValue, was: %T`, earnedAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	envVal, ok := envAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ObjectValue, was: %T`, envAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageNameAttribute, ok := attributes["image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_name is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	imageNameVal, ok := imageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_name expected to be basetypes.StringValue, was: %T`, imageNameAttribute))
	}

	isPublicAttribute, ok := attributes["is_public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_public is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	isPublicVal, ok := isPublicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_public expected to be basetypes.BoolValue, was: %T`, isPublicAttribute))
	}

	isRunpodAttribute, ok := attributes["is_runpod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_runpod is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	isRunpodVal, ok := isRunpodAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_runpod expected to be basetypes.BoolValue, was: %T`, isRunpodAttribute))
	}

	isServerlessAttribute, ok := attributes["is_serverless"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_serverless is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	isServerlessVal, ok := isServerlessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_serverless expected to be basetypes.BoolValue, was: %T`, isServerlessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	readmeAttribute, ok := attributes["readme"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`readme is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	readmeVal, ok := readmeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`readme expected to be basetypes.StringValue, was: %T`, readmeAttribute))
	}

	runtimeInMinAttribute, ok := attributes["runtime_in_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`runtime_in_min is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	runtimeInMinVal, ok := runtimeInMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`runtime_in_min expected to be basetypes.Int64Value, was: %T`, runtimeInMinAttribute))
	}

	volumeInGbAttribute, ok := attributes["volume_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_in_gb is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	volumeInGbVal, ok := volumeInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_in_gb expected to be basetypes.Int64Value, was: %T`, volumeInGbAttribute))
	}

	volumeMountPathAttribute, ok := attributes["volume_mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_mount_path is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	volumeMountPathVal, ok := volumeMountPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_mount_path expected to be basetypes.StringValue, was: %T`, volumeMountPathAttribute))
	}

	if diags.HasError() {
		return NewTemplateValueUnknown(), diags
	}

	return TemplateValue{
		Category:                categoryVal,
		ContainerDiskInGb:       containerDiskInGbVal,
		ContainerRegistryAuthId: containerRegistryAuthIdVal,
		DockerEntrypoint:        dockerEntrypointVal,
		DockerStartCmd:          dockerStartCmdVal,
		Earned:                  earnedVal,
		Env:                     envVal,
		Id:                      idVal,
		ImageName:               imageNameVal,
		IsPublic:                isPublicVal,
		IsRunpod:                isRunpodVal,
		IsServerless:            isServerlessVal,
		Name:                    nameVal,
		Ports:                   portsVal,
		Readme:                  readmeVal,
		RuntimeInMin:            runtimeInMinVal,
		VolumeInGb:              volumeInGbVal,
		VolumeMountPath:         volumeMountPathVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewTemplateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TemplateValue {
	object, diags := NewTemplateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTemplateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TemplateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTemplateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTemplateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTemplateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTemplateValueMust(TemplateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TemplateType) ValueType(ctx context.Context) attr.Value {
	return TemplateValue{}
}

var _ basetypes.ObjectValuable = TemplateValue{}

type TemplateValue struct {
	Category                basetypes.StringValue `tfsdk:"category"`
	ContainerDiskInGb       basetypes.Int64Value  `tfsdk:"container_disk_in_gb"`
	ContainerRegistryAuthId basetypes.StringValue `tfsdk:"container_registry_auth_id"`
	DockerEntrypoint        basetypes.ListValue   `tfsdk:"docker_entrypoint"`
	DockerStartCmd          basetypes.ListValue   `tfsdk:"docker_start_cmd"`
	Earned                  basetypes.NumberValue `tfsdk:"earned"`
	Env                     basetypes.ObjectValue `tfsdk:"env"`
	Id                      basetypes.StringValue `tfsdk:"id"`
	ImageName               basetypes.StringValue `tfsdk:"image_name"`
	IsPublic                basetypes.BoolValue   `tfsdk:"is_public"`
	IsRunpod                basetypes.BoolValue   `tfsdk:"is_runpod"`
	IsServerless            basetypes.BoolValue   `tfsdk:"is_serverless"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	Ports                   basetypes.ListValue   `tfsdk:"ports"`
	Readme                  basetypes.StringValue `tfsdk:"readme"`
	RuntimeInMin            basetypes.Int64Value  `tfsdk:"runtime_in_min"`
	VolumeInGb              basetypes.Int64Value  `tfsdk:"volume_in_gb"`
	VolumeMountPath         basetypes.StringValue `tfsdk:"volume_mount_path"`
	state                   attr.ValueState
}

func (v TemplateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["category"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container_disk_in_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["container_registry_auth_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_entrypoint"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["docker_start_cmd"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["earned"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["env"] = basetypes.ObjectType{
		AttrTypes: EnvValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_public"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_runpod"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_serverless"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["readme"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["runtime_in_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_in_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_mount_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.Category.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["category"] = val

		val, err = v.ContainerDiskInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_disk_in_gb"] = val

		val, err = v.ContainerRegistryAuthId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_registry_auth_id"] = val

		val, err = v.DockerEntrypoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_entrypoint"] = val

		val, err = v.DockerStartCmd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_start_cmd"] = val

		val, err = v.Earned.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["earned"] = val

		val, err = v.Env.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["env"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ImageName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_name"] = val

		val, err = v.IsPublic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_public"] = val

		val, err = v.IsRunpod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_runpod"] = val

		val, err = v.IsServerless.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_serverless"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.Readme.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["readme"] = val

		val, err = v.RuntimeInMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["runtime_in_min"] = val

		val, err = v.VolumeInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_in_gb"] = val

		val, err = v.VolumeMountPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_mount_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TemplateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TemplateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TemplateValue) String() string {
	return "TemplateValue"
}

func (v TemplateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var env basetypes.ObjectValue

	if v.Env.IsNull() {
		env = types.ObjectNull(
			EnvValue{}.AttributeTypes(ctx),
		)
	}

	if v.Env.IsUnknown() {
		env = types.ObjectUnknown(
			EnvValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Env.IsNull() && !v.Env.IsUnknown() {
		env = types.ObjectValueMust(
			EnvValue{}.AttributeTypes(ctx),
			v.Env.Attributes(),
		)
	}

	var dockerEntrypointVal basetypes.ListValue
	switch {
	case v.DockerEntrypoint.IsUnknown():
		dockerEntrypointVal = types.ListUnknown(types.StringType)
	case v.DockerEntrypoint.IsNull():
		dockerEntrypointVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dockerEntrypointVal, d = types.ListValue(types.StringType, v.DockerEntrypoint.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"category":                   basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"earned": basetypes.NumberType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"id":            basetypes.StringType{},
			"image_name":    basetypes.StringType{},
			"is_public":     basetypes.BoolType{},
			"is_runpod":     basetypes.BoolType{},
			"is_serverless": basetypes.BoolType{},
			"name":          basetypes.StringType{},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"readme":            basetypes.StringType{},
			"runtime_in_min":    basetypes.Int64Type{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	var dockerStartCmdVal basetypes.ListValue
	switch {
	case v.DockerStartCmd.IsUnknown():
		dockerStartCmdVal = types.ListUnknown(types.StringType)
	case v.DockerStartCmd.IsNull():
		dockerStartCmdVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dockerStartCmdVal, d = types.ListValue(types.StringType, v.DockerStartCmd.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"category":                   basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"earned": basetypes.NumberType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"id":            basetypes.StringType{},
			"image_name":    basetypes.StringType{},
			"is_public":     basetypes.BoolType{},
			"is_runpod":     basetypes.BoolType{},
			"is_serverless": basetypes.BoolType{},
			"name":          basetypes.StringType{},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"readme":            basetypes.StringType{},
			"runtime_in_min":    basetypes.Int64Type{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	var portsVal basetypes.ListValue
	switch {
	case v.Ports.IsUnknown():
		portsVal = types.ListUnknown(types.StringType)
	case v.Ports.IsNull():
		portsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		portsVal, d = types.ListValue(types.StringType, v.Ports.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"category":                   basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"earned": basetypes.NumberType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"id":            basetypes.StringType{},
			"image_name":    basetypes.StringType{},
			"is_public":     basetypes.BoolType{},
			"is_runpod":     basetypes.BoolType{},
			"is_serverless": basetypes.BoolType{},
			"name":          basetypes.StringType{},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"readme":            basetypes.StringType{},
			"runtime_in_min":    basetypes.Int64Type{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"category":                   basetypes.StringType{},
		"container_disk_in_gb":       basetypes.Int64Type{},
		"container_registry_auth_id": basetypes.StringType{},
		"docker_entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"docker_start_cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"earned": basetypes.NumberType{},
		"env": basetypes.ObjectType{
			AttrTypes: EnvValue{}.AttributeTypes(ctx),
		},
		"id":            basetypes.StringType{},
		"image_name":    basetypes.StringType{},
		"is_public":     basetypes.BoolType{},
		"is_runpod":     basetypes.BoolType{},
		"is_serverless": basetypes.BoolType{},
		"name":          basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"readme":            basetypes.StringType{},
		"runtime_in_min":    basetypes.Int64Type{},
		"volume_in_gb":      basetypes.Int64Type{},
		"volume_mount_path": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"category":                   v.Category,
			"container_disk_in_gb":       v.ContainerDiskInGb,
			"container_registry_auth_id": v.ContainerRegistryAuthId,
			"docker_entrypoint":          dockerEntrypointVal,
			"docker_start_cmd":           dockerStartCmdVal,
			"earned":                     v.Earned,
			"env":                        env,
			"id":                         v.Id,
			"image_name":                 v.ImageName,
			"is_public":                  v.IsPublic,
			"is_runpod":                  v.IsRunpod,
			"is_serverless":              v.IsServerless,
			"name":                       v.Name,
			"ports":                      portsVal,
			"readme":                     v.Readme,
			"runtime_in_min":             v.RuntimeInMin,
			"volume_in_gb":               v.VolumeInGb,
			"volume_mount_path":          v.VolumeMountPath,
		})

	return objVal, diags
}

func (v TemplateValue) Equal(o attr.Value) bool {
	other, ok := o.(TemplateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Category.Equal(other.Category) {
		return false
	}

	if !v.ContainerDiskInGb.Equal(other.ContainerDiskInGb) {
		return false
	}

	if !v.ContainerRegistryAuthId.Equal(other.ContainerRegistryAuthId) {
		return false
	}

	if !v.DockerEntrypoint.Equal(other.DockerEntrypoint) {
		return false
	}

	if !v.DockerStartCmd.Equal(other.DockerStartCmd) {
		return false
	}

	if !v.Earned.Equal(other.Earned) {
		return false
	}

	if !v.Env.Equal(other.Env) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ImageName.Equal(other.ImageName) {
		return false
	}

	if !v.IsPublic.Equal(other.IsPublic) {
		return false
	}

	if !v.IsRunpod.Equal(other.IsRunpod) {
		return false
	}

	if !v.IsServerless.Equal(other.IsServerless) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.Readme.Equal(other.Readme) {
		return false
	}

	if !v.RuntimeInMin.Equal(other.RuntimeInMin) {
		return false
	}

	if !v.VolumeInGb.Equal(other.VolumeInGb) {
		return false
	}

	if !v.VolumeMountPath.Equal(other.VolumeMountPath) {
		return false
	}

	return true
}

func (v TemplateValue) Type(ctx context.Context) attr.Type {
	return TemplateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TemplateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"category":                   basetypes.StringType{},
		"container_disk_in_gb":       basetypes.Int64Type{},
		"container_registry_auth_id": basetypes.StringType{},
		"docker_entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"docker_start_cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"earned": basetypes.NumberType{},
		"env": basetypes.ObjectType{
			AttrTypes: EnvValue{}.AttributeTypes(ctx),
		},
		"id":            basetypes.StringType{},
		"image_name":    basetypes.StringType{},
		"is_public":     basetypes.BoolType{},
		"is_runpod":     basetypes.BoolType{},
		"is_serverless": basetypes.BoolType{},
		"name":          basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"readme":            basetypes.StringType{},
		"runtime_in_min":    basetypes.Int64Type{},
		"volume_in_gb":      basetypes.Int64Type{},
		"volume_mount_path": basetypes.StringType{},
	}
}


var _ basetypes.ObjectTypable = WorkersType{}

type WorkersType struct {
	basetypes.ObjectType
}

func (t WorkersType) Equal(o attr.Type) bool {
	other, ok := o.(WorkersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WorkersType) String() string {
	return "WorkersType"
}

func (t WorkersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adjustedCostPerHrAttribute, ok := attributes["adjusted_cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjusted_cost_per_hr is missing from object`)

		return nil, diags
	}

	adjustedCostPerHrVal, ok := adjustedCostPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjusted_cost_per_hr expected to be basetypes.NumberValue, was: %T`, adjustedCostPerHrAttribute))
	}

	aiApiIdAttribute, ok := attributes["ai_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai_api_id is missing from object`)

		return nil, diags
	}

	aiApiIdVal, ok := aiApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai_api_id expected to be basetypes.StringValue, was: %T`, aiApiIdAttribute))
	}

	consumerUserIdAttribute, ok := attributes["consumer_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumer_user_id is missing from object`)

		return nil, diags
	}

	consumerUserIdVal, ok := consumerUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumer_user_id expected to be basetypes.StringValue, was: %T`, consumerUserIdAttribute))
	}

	containerDiskInGbAttribute, ok := attributes["container_disk_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_disk_in_gb is missing from object`)

		return nil, diags
	}

	containerDiskInGbVal, ok := containerDiskInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_disk_in_gb expected to be basetypes.Int64Value, was: %T`, containerDiskInGbAttribute))
	}

	containerRegistryAuthIdAttribute, ok := attributes["container_registry_auth_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_registry_auth_id is missing from object`)

		return nil, diags
	}

	containerRegistryAuthIdVal, ok := containerRegistryAuthIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_registry_auth_id expected to be basetypes.StringValue, was: %T`, containerRegistryAuthIdAttribute))
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return nil, diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuFlavorIdAttribute, ok := attributes["cpu_flavor_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_flavor_id is missing from object`)

		return nil, diags
	}

	cpuFlavorIdVal, ok := cpuFlavorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_flavor_id expected to be basetypes.StringValue, was: %T`, cpuFlavorIdAttribute))
	}

	desiredStatusAttribute, ok := attributes["desired_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_status is missing from object`)

		return nil, diags
	}

	desiredStatusVal, ok := desiredStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_status expected to be basetypes.StringValue, was: %T`, desiredStatusAttribute))
	}

	dockerEntrypointAttribute, ok := attributes["docker_entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_entrypoint is missing from object`)

		return nil, diags
	}

	dockerEntrypointVal, ok := dockerEntrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_entrypoint expected to be basetypes.ListValue, was: %T`, dockerEntrypointAttribute))
	}

	dockerStartCmdAttribute, ok := attributes["docker_start_cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_start_cmd is missing from object`)

		return nil, diags
	}

	dockerStartCmdVal, ok := dockerStartCmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_start_cmd expected to be basetypes.ListValue, was: %T`, dockerStartCmdAttribute))
	}

	endpointIdAttribute, ok := attributes["endpoint_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_id is missing from object`)

		return nil, diags
	}

	endpointIdVal, ok := endpointIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_id expected to be basetypes.StringValue, was: %T`, endpointIdAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return nil, diags
	}

	envVal, ok := envAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ObjectValue, was: %T`, envAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return nil, diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.ObjectValue, was: %T`, gpuAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	interruptibleAttribute, ok := attributes["interruptible"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interruptible is missing from object`)

		return nil, diags
	}

	interruptibleVal, ok := interruptibleAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interruptible expected to be basetypes.BoolValue, was: %T`, interruptibleAttribute))
	}

	lastStartedAtAttribute, ok := attributes["last_started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_started_at is missing from object`)

		return nil, diags
	}

	lastStartedAtVal, ok := lastStartedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_started_at expected to be basetypes.StringValue, was: %T`, lastStartedAtAttribute))
	}

	lastStatusChangeAttribute, ok := attributes["last_status_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change is missing from object`)

		return nil, diags
	}

	lastStatusChangeVal, ok := lastStatusChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change expected to be basetypes.StringValue, was: %T`, lastStatusChangeAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return nil, diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	machineAttribute, ok := attributes["machine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine is missing from object`)

		return nil, diags
	}

	machineVal, ok := machineAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine expected to be basetypes.ObjectValue, was: %T`, machineAttribute))
	}

	machineIdAttribute, ok := attributes["machine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine_id is missing from object`)

		return nil, diags
	}

	machineIdVal, ok := machineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine_id expected to be basetypes.StringValue, was: %T`, machineIdAttribute))
	}

	memoryInGbAttribute, ok := attributes["memory_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_in_gb is missing from object`)

		return nil, diags
	}

	memoryInGbVal, ok := memoryInGbAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_in_gb expected to be basetypes.NumberValue, was: %T`, memoryInGbAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkVolumeAttribute, ok := attributes["network_volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_volume is missing from object`)

		return nil, diags
	}

	networkVolumeVal, ok := networkVolumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_volume expected to be basetypes.ObjectValue, was: %T`, networkVolumeAttribute))
	}

	portMappingsAttribute, ok := attributes["port_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mappings is missing from object`)

		return nil, diags
	}

	portMappingsVal, ok := portMappingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mappings expected to be basetypes.ObjectValue, was: %T`, portMappingsAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return nil, diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	savingsPlansAttribute, ok := attributes["savings_plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`savings_plans is missing from object`)

		return nil, diags
	}

	savingsPlansVal, ok := savingsPlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`savings_plans expected to be basetypes.ListValue, was: %T`, savingsPlansAttribute))
	}

	slsVersionAttribute, ok := attributes["sls_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sls_version is missing from object`)

		return nil, diags
	}

	slsVersionVal, ok := slsVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sls_version expected to be basetypes.Int64Value, was: %T`, slsVersionAttribute))
	}

	templateIdAttribute, ok := attributes["template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_id is missing from object`)

		return nil, diags
	}

	templateIdVal, ok := templateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_id expected to be basetypes.StringValue, was: %T`, templateIdAttribute))
	}

	vcpuCountAttribute, ok := attributes["vcpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_count is missing from object`)

		return nil, diags
	}

	vcpuCountVal, ok := vcpuCountAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_count expected to be basetypes.NumberValue, was: %T`, vcpuCountAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return nil, diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeInGbAttribute, ok := attributes["volume_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_in_gb is missing from object`)

		return nil, diags
	}

	volumeInGbVal, ok := volumeInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_in_gb expected to be basetypes.Int64Value, was: %T`, volumeInGbAttribute))
	}

	volumeMountPathAttribute, ok := attributes["volume_mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_mount_path is missing from object`)

		return nil, diags
	}

	volumeMountPathVal, ok := volumeMountPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_mount_path expected to be basetypes.StringValue, was: %T`, volumeMountPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WorkersValue{
		AdjustedCostPerHr:       adjustedCostPerHrVal,
		AiApiId:                 aiApiIdVal,
		ConsumerUserId:          consumerUserIdVal,
		ContainerDiskInGb:       containerDiskInGbVal,
		ContainerRegistryAuthId: containerRegistryAuthIdVal,
		CostPerHr:               costPerHrVal,
		CpuFlavorId:             cpuFlavorIdVal,
		DesiredStatus:           desiredStatusVal,
		DockerEntrypoint:        dockerEntrypointVal,
		DockerStartCmd:          dockerStartCmdVal,
		EndpointId:              endpointIdVal,
		Env:                     envVal,
		Gpu:                     gpuVal,
		Id:                      idVal,
		Image:                   imageVal,
		Interruptible:           interruptibleVal,
		LastStartedAt:           lastStartedAtVal,
		LastStatusChange:        lastStatusChangeVal,
		Locked:                  lockedVal,
		Machine:                 machineVal,
		MachineId:               machineIdVal,
		MemoryInGb:              memoryInGbVal,
		Name:                    nameVal,
		NetworkVolume:           networkVolumeVal,
		PortMappings:            portMappingsVal,
		Ports:                   portsVal,
		PublicIp:                publicIpVal,
		SavingsPlans:            savingsPlansVal,
		SlsVersion:              slsVersionVal,
		TemplateId:              templateIdVal,
		VcpuCount:               vcpuCountVal,
		VolumeEncrypted:         volumeEncryptedVal,
		VolumeInGb:              volumeInGbVal,
		VolumeMountPath:         volumeMountPathVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewWorkersValueNull() WorkersValue {
	return WorkersValue{
		state: attr.ValueStateNull,
	}
}

func NewWorkersValueUnknown() WorkersValue {
	return WorkersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWorkersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WorkersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WorkersValue Attribute Value",
				"While creating a WorkersValue value, a missing attribute value was detected. "+
					"A WorkersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WorkersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WorkersValue Attribute Type",
				"While creating a WorkersValue value, an invalid attribute value was detected. "+
					"A WorkersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WorkersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WorkersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WorkersValue Attribute Value",
				"While creating a WorkersValue value, an extra attribute value was detected. "+
					"A WorkersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WorkersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWorkersValueUnknown(), diags
	}

	adjustedCostPerHrAttribute, ok := attributes["adjusted_cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjusted_cost_per_hr is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	adjustedCostPerHrVal, ok := adjustedCostPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjusted_cost_per_hr expected to be basetypes.NumberValue, was: %T`, adjustedCostPerHrAttribute))
	}

	aiApiIdAttribute, ok := attributes["ai_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ai_api_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	aiApiIdVal, ok := aiApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ai_api_id expected to be basetypes.StringValue, was: %T`, aiApiIdAttribute))
	}

	consumerUserIdAttribute, ok := attributes["consumer_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumer_user_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	consumerUserIdVal, ok := consumerUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumer_user_id expected to be basetypes.StringValue, was: %T`, consumerUserIdAttribute))
	}

	containerDiskInGbAttribute, ok := attributes["container_disk_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_disk_in_gb is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	containerDiskInGbVal, ok := containerDiskInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_disk_in_gb expected to be basetypes.Int64Value, was: %T`, containerDiskInGbAttribute))
	}

	containerRegistryAuthIdAttribute, ok := attributes["container_registry_auth_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container_registry_auth_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	containerRegistryAuthIdVal, ok := containerRegistryAuthIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container_registry_auth_id expected to be basetypes.StringValue, was: %T`, containerRegistryAuthIdAttribute))
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuFlavorIdAttribute, ok := attributes["cpu_flavor_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_flavor_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	cpuFlavorIdVal, ok := cpuFlavorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_flavor_id expected to be basetypes.StringValue, was: %T`, cpuFlavorIdAttribute))
	}

	desiredStatusAttribute, ok := attributes["desired_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_status is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	desiredStatusVal, ok := desiredStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_status expected to be basetypes.StringValue, was: %T`, desiredStatusAttribute))
	}

	dockerEntrypointAttribute, ok := attributes["docker_entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_entrypoint is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	dockerEntrypointVal, ok := dockerEntrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_entrypoint expected to be basetypes.ListValue, was: %T`, dockerEntrypointAttribute))
	}

	dockerStartCmdAttribute, ok := attributes["docker_start_cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`docker_start_cmd is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	dockerStartCmdVal, ok := dockerStartCmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`docker_start_cmd expected to be basetypes.ListValue, was: %T`, dockerStartCmdAttribute))
	}

	endpointIdAttribute, ok := attributes["endpoint_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoint_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	endpointIdVal, ok := endpointIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoint_id expected to be basetypes.StringValue, was: %T`, endpointIdAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	envVal, ok := envAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ObjectValue, was: %T`, envAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.ObjectValue, was: %T`, gpuAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	interruptibleAttribute, ok := attributes["interruptible"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interruptible is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	interruptibleVal, ok := interruptibleAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interruptible expected to be basetypes.BoolValue, was: %T`, interruptibleAttribute))
	}

	lastStartedAtAttribute, ok := attributes["last_started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_started_at is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	lastStartedAtVal, ok := lastStartedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_started_at expected to be basetypes.StringValue, was: %T`, lastStartedAtAttribute))
	}

	lastStatusChangeAttribute, ok := attributes["last_status_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	lastStatusChangeVal, ok := lastStatusChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change expected to be basetypes.StringValue, was: %T`, lastStatusChangeAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	machineAttribute, ok := attributes["machine"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	machineVal, ok := machineAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine expected to be basetypes.ObjectValue, was: %T`, machineAttribute))
	}

	machineIdAttribute, ok := attributes["machine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	machineIdVal, ok := machineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine_id expected to be basetypes.StringValue, was: %T`, machineIdAttribute))
	}

	memoryInGbAttribute, ok := attributes["memory_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_in_gb is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	memoryInGbVal, ok := memoryInGbAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_in_gb expected to be basetypes.NumberValue, was: %T`, memoryInGbAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkVolumeAttribute, ok := attributes["network_volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_volume is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	networkVolumeVal, ok := networkVolumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_volume expected to be basetypes.ObjectValue, was: %T`, networkVolumeAttribute))
	}

	portMappingsAttribute, ok := attributes["port_mappings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mappings is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	portMappingsVal, ok := portMappingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mappings expected to be basetypes.ObjectValue, was: %T`, portMappingsAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	publicIpAttribute, ok := attributes["public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_ip is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	publicIpVal, ok := publicIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_ip expected to be basetypes.StringValue, was: %T`, publicIpAttribute))
	}

	savingsPlansAttribute, ok := attributes["savings_plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`savings_plans is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	savingsPlansVal, ok := savingsPlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`savings_plans expected to be basetypes.ListValue, was: %T`, savingsPlansAttribute))
	}

	slsVersionAttribute, ok := attributes["sls_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sls_version is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	slsVersionVal, ok := slsVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sls_version expected to be basetypes.Int64Value, was: %T`, slsVersionAttribute))
	}

	templateIdAttribute, ok := attributes["template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_id is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	templateIdVal, ok := templateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_id expected to be basetypes.StringValue, was: %T`, templateIdAttribute))
	}

	vcpuCountAttribute, ok := attributes["vcpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_count is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	vcpuCountVal, ok := vcpuCountAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_count expected to be basetypes.NumberValue, was: %T`, vcpuCountAttribute))
	}

	volumeEncryptedAttribute, ok := attributes["volume_encrypted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_encrypted is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	volumeEncryptedVal, ok := volumeEncryptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_encrypted expected to be basetypes.BoolValue, was: %T`, volumeEncryptedAttribute))
	}

	volumeInGbAttribute, ok := attributes["volume_in_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_in_gb is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	volumeInGbVal, ok := volumeInGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_in_gb expected to be basetypes.Int64Value, was: %T`, volumeInGbAttribute))
	}

	volumeMountPathAttribute, ok := attributes["volume_mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_mount_path is missing from object`)

		return NewWorkersValueUnknown(), diags
	}

	volumeMountPathVal, ok := volumeMountPathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_mount_path expected to be basetypes.StringValue, was: %T`, volumeMountPathAttribute))
	}

	if diags.HasError() {
		return NewWorkersValueUnknown(), diags
	}

	return WorkersValue{
		AdjustedCostPerHr:       adjustedCostPerHrVal,
		AiApiId:                 aiApiIdVal,
		ConsumerUserId:          consumerUserIdVal,
		ContainerDiskInGb:       containerDiskInGbVal,
		ContainerRegistryAuthId: containerRegistryAuthIdVal,
		CostPerHr:               costPerHrVal,
		CpuFlavorId:             cpuFlavorIdVal,
		DesiredStatus:           desiredStatusVal,
		DockerEntrypoint:        dockerEntrypointVal,
		DockerStartCmd:          dockerStartCmdVal,
		EndpointId:              endpointIdVal,
		Env:                     envVal,
		Gpu:                     gpuVal,
		Id:                      idVal,
		Image:                   imageVal,
		Interruptible:           interruptibleVal,
		LastStartedAt:           lastStartedAtVal,
		LastStatusChange:        lastStatusChangeVal,
		Locked:                  lockedVal,
		Machine:                 machineVal,
		MachineId:               machineIdVal,
		MemoryInGb:              memoryInGbVal,
		Name:                    nameVal,
		NetworkVolume:           networkVolumeVal,
		PortMappings:            portMappingsVal,
		Ports:                   portsVal,
		PublicIp:                publicIpVal,
		SavingsPlans:            savingsPlansVal,
		SlsVersion:              slsVersionVal,
		TemplateId:              templateIdVal,
		VcpuCount:               vcpuCountVal,
		VolumeEncrypted:         volumeEncryptedVal,
		VolumeInGb:              volumeInGbVal,
		VolumeMountPath:         volumeMountPathVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewWorkersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WorkersValue {
	object, diags := NewWorkersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWorkersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WorkersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWorkersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWorkersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWorkersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWorkersValueMust(WorkersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WorkersType) ValueType(ctx context.Context) attr.Value {
	return WorkersValue{}
}

var _ basetypes.ObjectValuable = WorkersValue{}

type WorkersValue struct {
	AdjustedCostPerHr       basetypes.NumberValue `tfsdk:"adjusted_cost_per_hr"`
	AiApiId                 basetypes.StringValue `tfsdk:"ai_api_id"`
	ConsumerUserId          basetypes.StringValue `tfsdk:"consumer_user_id"`
	ContainerDiskInGb       basetypes.Int64Value  `tfsdk:"container_disk_in_gb"`
	ContainerRegistryAuthId basetypes.StringValue `tfsdk:"container_registry_auth_id"`
	CostPerHr               basetypes.NumberValue `tfsdk:"cost_per_hr"`
	CpuFlavorId             basetypes.StringValue `tfsdk:"cpu_flavor_id"`
	DesiredStatus           basetypes.StringValue `tfsdk:"desired_status"`
	DockerEntrypoint        basetypes.ListValue   `tfsdk:"docker_entrypoint"`
	DockerStartCmd          basetypes.ListValue   `tfsdk:"docker_start_cmd"`
	EndpointId              basetypes.StringValue `tfsdk:"endpoint_id"`
	Env                     basetypes.ObjectValue `tfsdk:"env"`
	Gpu                     basetypes.ObjectValue `tfsdk:"gpu"`
	Id                      basetypes.StringValue `tfsdk:"id"`
	Image                   basetypes.StringValue `tfsdk:"image"`
	Interruptible           basetypes.BoolValue   `tfsdk:"interruptible"`
	LastStartedAt           basetypes.StringValue `tfsdk:"last_started_at"`
	LastStatusChange        basetypes.StringValue `tfsdk:"last_status_change"`
	Locked                  basetypes.BoolValue   `tfsdk:"locked"`
	Machine                 basetypes.ObjectValue `tfsdk:"machine"`
	MachineId               basetypes.StringValue `tfsdk:"machine_id"`
	MemoryInGb              basetypes.NumberValue `tfsdk:"memory_in_gb"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	NetworkVolume           basetypes.ObjectValue `tfsdk:"network_volume"`
	PortMappings            basetypes.ObjectValue `tfsdk:"port_mappings"`
	Ports                   basetypes.ListValue   `tfsdk:"ports"`
	PublicIp                basetypes.StringValue `tfsdk:"public_ip"`
	SavingsPlans            basetypes.ListValue   `tfsdk:"savings_plans"`
	SlsVersion              basetypes.Int64Value  `tfsdk:"sls_version"`
	TemplateId              basetypes.StringValue `tfsdk:"template_id"`
	VcpuCount               basetypes.NumberValue `tfsdk:"vcpu_count"`
	VolumeEncrypted         basetypes.BoolValue   `tfsdk:"volume_encrypted"`
	VolumeInGb              basetypes.Int64Value  `tfsdk:"volume_in_gb"`
	VolumeMountPath         basetypes.StringValue `tfsdk:"volume_mount_path"`
	state                   attr.ValueState
}

func (v WorkersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 34)

	var val tftypes.Value
	var err error

	attrTypes["adjusted_cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["ai_api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["consumer_user_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container_disk_in_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["container_registry_auth_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["cpu_flavor_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["desired_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["docker_entrypoint"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["docker_start_cmd"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["endpoint_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["env"] = basetypes.ObjectType{
		AttrTypes: EnvValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gpu"] = basetypes.ObjectType{
		AttrTypes: GpuValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interruptible"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["last_started_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_status_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["locked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["machine"] = basetypes.ObjectType{
		AttrTypes: MachineValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["machine_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory_in_gb"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_volume"] = basetypes.ObjectType{
		AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mappings"] = basetypes.ObjectType{
		AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["public_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["savings_plans"] = basetypes.ListType{
		ElemType: SavingsPlansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["sls_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["template_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpu_count"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["volume_encrypted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume_in_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_mount_path"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 34)

		val, err = v.AdjustedCostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["adjusted_cost_per_hr"] = val

		val, err = v.AiApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ai_api_id"] = val

		val, err = v.ConsumerUserId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["consumer_user_id"] = val

		val, err = v.ContainerDiskInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_disk_in_gb"] = val

		val, err = v.ContainerRegistryAuthId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container_registry_auth_id"] = val

		val, err = v.CostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost_per_hr"] = val

		val, err = v.CpuFlavorId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_flavor_id"] = val

		val, err = v.DesiredStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_status"] = val

		val, err = v.DockerEntrypoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_entrypoint"] = val

		val, err = v.DockerStartCmd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["docker_start_cmd"] = val

		val, err = v.EndpointId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoint_id"] = val

		val, err = v.Env.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["env"] = val

		val, err = v.Gpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Interruptible.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interruptible"] = val

		val, err = v.LastStartedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_started_at"] = val

		val, err = v.LastStatusChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_status_change"] = val

		val, err = v.Locked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locked"] = val

		val, err = v.Machine.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["machine"] = val

		val, err = v.MachineId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["machine_id"] = val

		val, err = v.MemoryInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_in_gb"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetworkVolume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_volume"] = val

		val, err = v.PortMappings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mappings"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.PublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_ip"] = val

		val, err = v.SavingsPlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["savings_plans"] = val

		val, err = v.SlsVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sls_version"] = val

		val, err = v.TemplateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template_id"] = val

		val, err = v.VcpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpu_count"] = val

		val, err = v.VolumeEncrypted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_encrypted"] = val

		val, err = v.VolumeInGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_in_gb"] = val

		val, err = v.VolumeMountPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_mount_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WorkersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WorkersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WorkersValue) String() string {
	return "WorkersValue"
}

func (v WorkersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var env basetypes.ObjectValue

	if v.Env.IsNull() {
		env = types.ObjectNull(
			EnvValue{}.AttributeTypes(ctx),
		)
	}

	if v.Env.IsUnknown() {
		env = types.ObjectUnknown(
			EnvValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Env.IsNull() && !v.Env.IsUnknown() {
		env = types.ObjectValueMust(
			EnvValue{}.AttributeTypes(ctx),
			v.Env.Attributes(),
		)
	}

	var gpu basetypes.ObjectValue

	if v.Gpu.IsNull() {
		gpu = types.ObjectNull(
			GpuValue{}.AttributeTypes(ctx),
		)
	}

	if v.Gpu.IsUnknown() {
		gpu = types.ObjectUnknown(
			GpuValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Gpu.IsNull() && !v.Gpu.IsUnknown() {
		gpu = types.ObjectValueMust(
			GpuValue{}.AttributeTypes(ctx),
			v.Gpu.Attributes(),
		)
	}

	var machine basetypes.ObjectValue

	if v.Machine.IsNull() {
		machine = types.ObjectNull(
			MachineValue{}.AttributeTypes(ctx),
		)
	}

	if v.Machine.IsUnknown() {
		machine = types.ObjectUnknown(
			MachineValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Machine.IsNull() && !v.Machine.IsUnknown() {
		machine = types.ObjectValueMust(
			MachineValue{}.AttributeTypes(ctx),
			v.Machine.Attributes(),
		)
	}

	var networkVolume basetypes.ObjectValue

	if v.NetworkVolume.IsNull() {
		networkVolume = types.ObjectNull(
			NetworkVolumeValue{}.AttributeTypes(ctx),
		)
	}

	if v.NetworkVolume.IsUnknown() {
		networkVolume = types.ObjectUnknown(
			NetworkVolumeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NetworkVolume.IsNull() && !v.NetworkVolume.IsUnknown() {
		networkVolume = types.ObjectValueMust(
			NetworkVolumeValue{}.AttributeTypes(ctx),
			v.NetworkVolume.Attributes(),
		)
	}

	var portMappings basetypes.ObjectValue

	if v.PortMappings.IsNull() {
		portMappings = types.ObjectNull(
			PortMappingsValue{}.AttributeTypes(ctx),
		)
	}

	if v.PortMappings.IsUnknown() {
		portMappings = types.ObjectUnknown(
			PortMappingsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PortMappings.IsNull() && !v.PortMappings.IsUnknown() {
		portMappings = types.ObjectValueMust(
			PortMappingsValue{}.AttributeTypes(ctx),
			v.PortMappings.Attributes(),
		)
	}

	savingsPlans := types.ListValueMust(
		SavingsPlansType{
			basetypes.ObjectType{
				AttrTypes: SavingsPlansValue{}.AttributeTypes(ctx),
			},
		},
		v.SavingsPlans.Elements(),
	)

	if v.SavingsPlans.IsNull() {
		savingsPlans = types.ListNull(
			SavingsPlansType{
				basetypes.ObjectType{
					AttrTypes: SavingsPlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SavingsPlans.IsUnknown() {
		savingsPlans = types.ListUnknown(
			SavingsPlansType{
				basetypes.ObjectType{
					AttrTypes: SavingsPlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var dockerEntrypointVal basetypes.ListValue
	switch {
	case v.DockerEntrypoint.IsUnknown():
		dockerEntrypointVal = types.ListUnknown(types.StringType)
	case v.DockerEntrypoint.IsNull():
		dockerEntrypointVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dockerEntrypointVal, d = types.ListValue(types.StringType, v.DockerEntrypoint.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"adjusted_cost_per_hr":       basetypes.NumberType{},
			"ai_api_id":                  basetypes.StringType{},
			"consumer_user_id":           basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"cost_per_hr":                basetypes.NumberType{},
			"cpu_flavor_id":              basetypes.StringType{},
			"desired_status":             basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"endpoint_id": basetypes.StringType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"gpu": basetypes.ObjectType{
				AttrTypes: GpuValue{}.AttributeTypes(ctx),
			},
			"id":                 basetypes.StringType{},
			"image":              basetypes.StringType{},
			"interruptible":      basetypes.BoolType{},
			"last_started_at":    basetypes.StringType{},
			"last_status_change": basetypes.StringType{},
			"locked":             basetypes.BoolType{},
			"machine": basetypes.ObjectType{
				AttrTypes: MachineValue{}.AttributeTypes(ctx),
			},
			"machine_id":   basetypes.StringType{},
			"memory_in_gb": basetypes.NumberType{},
			"name":         basetypes.StringType{},
			"network_volume": basetypes.ObjectType{
				AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
			},
			"port_mappings": basetypes.ObjectType{
				AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"public_ip": basetypes.StringType{},
			"savings_plans": basetypes.ListType{
				ElemType: SavingsPlansValue{}.Type(ctx),
			},
			"sls_version":       basetypes.Int64Type{},
			"template_id":       basetypes.StringType{},
			"vcpu_count":        basetypes.NumberType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	var dockerStartCmdVal basetypes.ListValue
	switch {
	case v.DockerStartCmd.IsUnknown():
		dockerStartCmdVal = types.ListUnknown(types.StringType)
	case v.DockerStartCmd.IsNull():
		dockerStartCmdVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dockerStartCmdVal, d = types.ListValue(types.StringType, v.DockerStartCmd.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"adjusted_cost_per_hr":       basetypes.NumberType{},
			"ai_api_id":                  basetypes.StringType{},
			"consumer_user_id":           basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"cost_per_hr":                basetypes.NumberType{},
			"cpu_flavor_id":              basetypes.StringType{},
			"desired_status":             basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"endpoint_id": basetypes.StringType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"gpu": basetypes.ObjectType{
				AttrTypes: GpuValue{}.AttributeTypes(ctx),
			},
			"id":                 basetypes.StringType{},
			"image":              basetypes.StringType{},
			"interruptible":      basetypes.BoolType{},
			"last_started_at":    basetypes.StringType{},
			"last_status_change": basetypes.StringType{},
			"locked":             basetypes.BoolType{},
			"machine": basetypes.ObjectType{
				AttrTypes: MachineValue{}.AttributeTypes(ctx),
			},
			"machine_id":   basetypes.StringType{},
			"memory_in_gb": basetypes.NumberType{},
			"name":         basetypes.StringType{},
			"network_volume": basetypes.ObjectType{
				AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
			},
			"port_mappings": basetypes.ObjectType{
				AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"public_ip": basetypes.StringType{},
			"savings_plans": basetypes.ListType{
				ElemType: SavingsPlansValue{}.Type(ctx),
			},
			"sls_version":       basetypes.Int64Type{},
			"template_id":       basetypes.StringType{},
			"vcpu_count":        basetypes.NumberType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	var portsVal basetypes.ListValue
	switch {
	case v.Ports.IsUnknown():
		portsVal = types.ListUnknown(types.StringType)
	case v.Ports.IsNull():
		portsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		portsVal, d = types.ListValue(types.StringType, v.Ports.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"adjusted_cost_per_hr":       basetypes.NumberType{},
			"ai_api_id":                  basetypes.StringType{},
			"consumer_user_id":           basetypes.StringType{},
			"container_disk_in_gb":       basetypes.Int64Type{},
			"container_registry_auth_id": basetypes.StringType{},
			"cost_per_hr":                basetypes.NumberType{},
			"cpu_flavor_id":              basetypes.StringType{},
			"desired_status":             basetypes.StringType{},
			"docker_entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"docker_start_cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"endpoint_id": basetypes.StringType{},
			"env": basetypes.ObjectType{
				AttrTypes: EnvValue{}.AttributeTypes(ctx),
			},
			"gpu": basetypes.ObjectType{
				AttrTypes: GpuValue{}.AttributeTypes(ctx),
			},
			"id":                 basetypes.StringType{},
			"image":              basetypes.StringType{},
			"interruptible":      basetypes.BoolType{},
			"last_started_at":    basetypes.StringType{},
			"last_status_change": basetypes.StringType{},
			"locked":             basetypes.BoolType{},
			"machine": basetypes.ObjectType{
				AttrTypes: MachineValue{}.AttributeTypes(ctx),
			},
			"machine_id":   basetypes.StringType{},
			"memory_in_gb": basetypes.NumberType{},
			"name":         basetypes.StringType{},
			"network_volume": basetypes.ObjectType{
				AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
			},
			"port_mappings": basetypes.ObjectType{
				AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"public_ip": basetypes.StringType{},
			"savings_plans": basetypes.ListType{
				ElemType: SavingsPlansValue{}.Type(ctx),
			},
			"sls_version":       basetypes.Int64Type{},
			"template_id":       basetypes.StringType{},
			"vcpu_count":        basetypes.NumberType{},
			"volume_encrypted":  basetypes.BoolType{},
			"volume_in_gb":      basetypes.Int64Type{},
			"volume_mount_path": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"adjusted_cost_per_hr":       basetypes.NumberType{},
		"ai_api_id":                  basetypes.StringType{},
		"consumer_user_id":           basetypes.StringType{},
		"container_disk_in_gb":       basetypes.Int64Type{},
		"container_registry_auth_id": basetypes.StringType{},
		"cost_per_hr":                basetypes.NumberType{},
		"cpu_flavor_id":              basetypes.StringType{},
		"desired_status":             basetypes.StringType{},
		"docker_entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"docker_start_cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"endpoint_id": basetypes.StringType{},
		"env": basetypes.ObjectType{
			AttrTypes: EnvValue{}.AttributeTypes(ctx),
		},
		"gpu": basetypes.ObjectType{
			AttrTypes: GpuValue{}.AttributeTypes(ctx),
		},
		"id":                 basetypes.StringType{},
		"image":              basetypes.StringType{},
		"interruptible":      basetypes.BoolType{},
		"last_started_at":    basetypes.StringType{},
		"last_status_change": basetypes.StringType{},
		"locked":             basetypes.BoolType{},
		"machine": basetypes.ObjectType{
			AttrTypes: MachineValue{}.AttributeTypes(ctx),
		},
		"machine_id":   basetypes.StringType{},
		"memory_in_gb": basetypes.NumberType{},
		"name":         basetypes.StringType{},
		"network_volume": basetypes.ObjectType{
			AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
		},
		"port_mappings": basetypes.ObjectType{
			AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
		},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"public_ip": basetypes.StringType{},
		"savings_plans": basetypes.ListType{
			ElemType: SavingsPlansValue{}.Type(ctx),
		},
		"sls_version":       basetypes.Int64Type{},
		"template_id":       basetypes.StringType{},
		"vcpu_count":        basetypes.NumberType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_in_gb":      basetypes.Int64Type{},
		"volume_mount_path": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"adjusted_cost_per_hr":       v.AdjustedCostPerHr,
			"ai_api_id":                  v.AiApiId,
			"consumer_user_id":           v.ConsumerUserId,
			"container_disk_in_gb":       v.ContainerDiskInGb,
			"container_registry_auth_id": v.ContainerRegistryAuthId,
			"cost_per_hr":                v.CostPerHr,
			"cpu_flavor_id":              v.CpuFlavorId,
			"desired_status":             v.DesiredStatus,
			"docker_entrypoint":          dockerEntrypointVal,
			"docker_start_cmd":           dockerStartCmdVal,
			"endpoint_id":                v.EndpointId,
			"env":                        env,
			"gpu":                        gpu,
			"id":                         v.Id,
			"image":                      v.Image,
			"interruptible":              v.Interruptible,
			"last_started_at":            v.LastStartedAt,
			"last_status_change":         v.LastStatusChange,
			"locked":                     v.Locked,
			"machine":                    machine,
			"machine_id":                 v.MachineId,
			"memory_in_gb":               v.MemoryInGb,
			"name":                       v.Name,
			"network_volume":             networkVolume,
			"port_mappings":              portMappings,
			"ports":                      portsVal,
			"public_ip":                  v.PublicIp,
			"savings_plans":              savingsPlans,
			"sls_version":                v.SlsVersion,
			"template_id":                v.TemplateId,
			"vcpu_count":                 v.VcpuCount,
			"volume_encrypted":           v.VolumeEncrypted,
			"volume_in_gb":               v.VolumeInGb,
			"volume_mount_path":          v.VolumeMountPath,
		})

	return objVal, diags
}

func (v WorkersValue) Equal(o attr.Value) bool {
	other, ok := o.(WorkersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdjustedCostPerHr.Equal(other.AdjustedCostPerHr) {
		return false
	}

	if !v.AiApiId.Equal(other.AiApiId) {
		return false
	}

	if !v.ConsumerUserId.Equal(other.ConsumerUserId) {
		return false
	}

	if !v.ContainerDiskInGb.Equal(other.ContainerDiskInGb) {
		return false
	}

	if !v.ContainerRegistryAuthId.Equal(other.ContainerRegistryAuthId) {
		return false
	}

	if !v.CostPerHr.Equal(other.CostPerHr) {
		return false
	}

	if !v.CpuFlavorId.Equal(other.CpuFlavorId) {
		return false
	}

	if !v.DesiredStatus.Equal(other.DesiredStatus) {
		return false
	}

	if !v.DockerEntrypoint.Equal(other.DockerEntrypoint) {
		return false
	}

	if !v.DockerStartCmd.Equal(other.DockerStartCmd) {
		return false
	}

	if !v.EndpointId.Equal(other.EndpointId) {
		return false
	}

	if !v.Env.Equal(other.Env) {
		return false
	}

	if !v.Gpu.Equal(other.Gpu) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Interruptible.Equal(other.Interruptible) {
		return false
	}

	if !v.LastStartedAt.Equal(other.LastStartedAt) {
		return false
	}

	if !v.LastStatusChange.Equal(other.LastStatusChange) {
		return false
	}

	if !v.Locked.Equal(other.Locked) {
		return false
	}

	if !v.Machine.Equal(other.Machine) {
		return false
	}

	if !v.MachineId.Equal(other.MachineId) {
		return false
	}

	if !v.MemoryInGb.Equal(other.MemoryInGb) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetworkVolume.Equal(other.NetworkVolume) {
		return false
	}

	if !v.PortMappings.Equal(other.PortMappings) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.PublicIp.Equal(other.PublicIp) {
		return false
	}

	if !v.SavingsPlans.Equal(other.SavingsPlans) {
		return false
	}

	if !v.SlsVersion.Equal(other.SlsVersion) {
		return false
	}

	if !v.TemplateId.Equal(other.TemplateId) {
		return false
	}

	if !v.VcpuCount.Equal(other.VcpuCount) {
		return false
	}

	if !v.VolumeEncrypted.Equal(other.VolumeEncrypted) {
		return false
	}

	if !v.VolumeInGb.Equal(other.VolumeInGb) {
		return false
	}

	if !v.VolumeMountPath.Equal(other.VolumeMountPath) {
		return false
	}

	return true
}

func (v WorkersValue) Type(ctx context.Context) attr.Type {
	return WorkersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WorkersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"adjusted_cost_per_hr":       basetypes.NumberType{},
		"ai_api_id":                  basetypes.StringType{},
		"consumer_user_id":           basetypes.StringType{},
		"container_disk_in_gb":       basetypes.Int64Type{},
		"container_registry_auth_id": basetypes.StringType{},
		"cost_per_hr":                basetypes.NumberType{},
		"cpu_flavor_id":              basetypes.StringType{},
		"desired_status":             basetypes.StringType{},
		"docker_entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"docker_start_cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"endpoint_id": basetypes.StringType{},
		"env": basetypes.ObjectType{
			AttrTypes: EnvValue{}.AttributeTypes(ctx),
		},
		"gpu": basetypes.ObjectType{
			AttrTypes: GpuValue{}.AttributeTypes(ctx),
		},
		"id":                 basetypes.StringType{},
		"image":              basetypes.StringType{},
		"interruptible":      basetypes.BoolType{},
		"last_started_at":    basetypes.StringType{},
		"last_status_change": basetypes.StringType{},
		"locked":             basetypes.BoolType{},
		"machine": basetypes.ObjectType{
			AttrTypes: MachineValue{}.AttributeTypes(ctx),
		},
		"machine_id":   basetypes.StringType{},
		"memory_in_gb": basetypes.NumberType{},
		"name":         basetypes.StringType{},
		"network_volume": basetypes.ObjectType{
			AttrTypes: NetworkVolumeValue{}.AttributeTypes(ctx),
		},
		"port_mappings": basetypes.ObjectType{
			AttrTypes: PortMappingsValue{}.AttributeTypes(ctx),
		},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"public_ip": basetypes.StringType{},
		"savings_plans": basetypes.ListType{
			ElemType: SavingsPlansValue{}.Type(ctx),
		},
		"sls_version":       basetypes.Int64Type{},
		"template_id":       basetypes.StringType{},
		"vcpu_count":        basetypes.NumberType{},
		"volume_encrypted":  basetypes.BoolType{},
		"volume_in_gb":      basetypes.Int64Type{},
		"volume_mount_path": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EnvType{}


var _ basetypes.ObjectTypable = GpuType{}

type GpuType struct {
	basetypes.ObjectType
}

func (t GpuType) Equal(o attr.Type) bool {
	other, ok := o.(GpuType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GpuType) String() string {
	return "GpuType"
}

func (t GpuType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return nil, diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return nil, diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return nil, diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return nil, diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return nil, diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return nil, diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return nil, diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return nil, diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GpuValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuValueNull() GpuValue {
	return GpuValue{
		state: attr.ValueStateNull,
	}
}

func NewGpuValueUnknown() GpuValue {
	return GpuValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGpuValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GpuValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GpuValue Attribute Value",
				"While creating a GpuValue value, a missing attribute value was detected. "+
					"A GpuValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GpuValue Attribute Type",
				"While creating a GpuValue value, an invalid attribute value was detected. "+
					"A GpuValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GpuValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GpuValue Attribute Value",
				"While creating a GpuValue value, an extra attribute value was detected. "+
					"A GpuValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GpuValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGpuValueUnknown(), diags
	}

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return NewGpuValueUnknown(), diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return NewGpuValueUnknown(), diags
	}

	return GpuValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GpuValue {
	object, diags := NewGpuValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGpuValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GpuType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGpuValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGpuValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGpuValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGpuValueMust(GpuValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GpuType) ValueType(ctx context.Context) attr.Value {
	return GpuValue{}
}

var _ basetypes.ObjectValuable = GpuValue{}

type GpuValue struct {
	CommunityPrice     basetypes.NumberValue `tfsdk:"community_price"`
	CommunitySpotPrice basetypes.NumberValue `tfsdk:"community_spot_price"`
	Count              basetypes.Int64Value  `tfsdk:"count"`
	DisplayName        basetypes.StringValue `tfsdk:"display_name"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	OneMonthPrice      basetypes.NumberValue `tfsdk:"one_month_price"`
	OneWeekPrice       basetypes.NumberValue `tfsdk:"one_week_price"`
	SecurePrice        basetypes.NumberValue `tfsdk:"secure_price"`
	SecureSpotPrice    basetypes.NumberValue `tfsdk:"secure_spot_price"`
	SixMonthPrice      basetypes.NumberValue `tfsdk:"six_month_price"`
	ThreeMonthPrice    basetypes.NumberValue `tfsdk:"three_month_price"`
	state              attr.ValueState
}

func (v GpuValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["community_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["community_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["one_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["one_week_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["six_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["three_month_price"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CommunityPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_price"] = val

		val, err = v.CommunitySpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_spot_price"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.OneMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_month_price"] = val

		val, err = v.OneWeekPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_week_price"] = val

		val, err = v.SecurePrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_price"] = val

		val, err = v.SecureSpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_spot_price"] = val

		val, err = v.SixMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["six_month_price"] = val

		val, err = v.ThreeMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["three_month_price"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GpuValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GpuValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GpuValue) String() string {
	return "GpuValue"
}

func (v GpuValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"community_price":      v.CommunityPrice,
			"community_spot_price": v.CommunitySpotPrice,
			"count":                v.Count,
			"display_name":         v.DisplayName,
			"id":                   v.Id,
			"one_month_price":      v.OneMonthPrice,
			"one_week_price":       v.OneWeekPrice,
			"secure_price":         v.SecurePrice,
			"secure_spot_price":    v.SecureSpotPrice,
			"six_month_price":      v.SixMonthPrice,
			"three_month_price":    v.ThreeMonthPrice,
		})

	return objVal, diags
}

func (v GpuValue) Equal(o attr.Value) bool {
	other, ok := o.(GpuValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommunityPrice.Equal(other.CommunityPrice) {
		return false
	}

	if !v.CommunitySpotPrice.Equal(other.CommunitySpotPrice) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.OneMonthPrice.Equal(other.OneMonthPrice) {
		return false
	}

	if !v.OneWeekPrice.Equal(other.OneWeekPrice) {
		return false
	}

	if !v.SecurePrice.Equal(other.SecurePrice) {
		return false
	}

	if !v.SecureSpotPrice.Equal(other.SecureSpotPrice) {
		return false
	}

	if !v.SixMonthPrice.Equal(other.SixMonthPrice) {
		return false
	}

	if !v.ThreeMonthPrice.Equal(other.ThreeMonthPrice) {
		return false
	}

	return true
}

func (v GpuValue) Type(ctx context.Context) attr.Type {
	return GpuType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GpuValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = MachineType{}

type MachineType struct {
	basetypes.ObjectType
}

func (t MachineType) Equal(o attr.Type) bool {
	other, ok := o.(MachineType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MachineType) String() string {
	return "MachineType"
}

func (t MachineType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return nil, diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuCountAttribute, ok := attributes["cpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_count is missing from object`)

		return nil, diags
	}

	cpuCountVal, ok := cpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_count expected to be basetypes.Int64Value, was: %T`, cpuCountAttribute))
	}

	cpuTypeAttribute, ok := attributes["cpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type is missing from object`)

		return nil, diags
	}

	cpuTypeVal, ok := cpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type expected to be basetypes.ObjectValue, was: %T`, cpuTypeAttribute))
	}

	cpuTypeIdAttribute, ok := attributes["cpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type_id is missing from object`)

		return nil, diags
	}

	cpuTypeIdVal, ok := cpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type_id expected to be basetypes.StringValue, was: %T`, cpuTypeIdAttribute))
	}

	currentPricePerGpuAttribute, ok := attributes["current_price_per_gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_price_per_gpu is missing from object`)

		return nil, diags
	}

	currentPricePerGpuVal, ok := currentPricePerGpuAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_price_per_gpu expected to be basetypes.NumberValue, was: %T`, currentPricePerGpuAttribute))
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return nil, diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	diskThroughputMbpsAttribute, ok := attributes["disk_throughput_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_throughput_mbps is missing from object`)

		return nil, diags
	}

	diskThroughputMbpsVal, ok := diskThroughputMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_throughput_mbps expected to be basetypes.Int64Value, was: %T`, diskThroughputMbpsAttribute))
	}

	gpuAvailableAttribute, ok := attributes["gpu_available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_available is missing from object`)

		return nil, diags
	}

	gpuAvailableVal, ok := gpuAvailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_available expected to be basetypes.Int64Value, was: %T`, gpuAvailableAttribute))
	}

	gpuDisplayNameAttribute, ok := attributes["gpu_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_display_name is missing from object`)

		return nil, diags
	}

	gpuDisplayNameVal, ok := gpuDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_display_name expected to be basetypes.StringValue, was: %T`, gpuDisplayNameAttribute))
	}

	gpuTypeAttribute, ok := attributes["gpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type is missing from object`)

		return nil, diags
	}

	gpuTypeVal, ok := gpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type expected to be basetypes.ObjectValue, was: %T`, gpuTypeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return nil, diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	maintenanceEndAttribute, ok := attributes["maintenance_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_end is missing from object`)

		return nil, diags
	}

	maintenanceEndVal, ok := maintenanceEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_end expected to be basetypes.StringValue, was: %T`, maintenanceEndAttribute))
	}

	maintenanceNoteAttribute, ok := attributes["maintenance_note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_note is missing from object`)

		return nil, diags
	}

	maintenanceNoteVal, ok := maintenanceNoteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_note expected to be basetypes.StringValue, was: %T`, maintenanceNoteAttribute))
	}

	maintenanceStartAttribute, ok := attributes["maintenance_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_start is missing from object`)

		return nil, diags
	}

	maintenanceStartVal, ok := maintenanceStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_start expected to be basetypes.StringValue, was: %T`, maintenanceStartAttribute))
	}

	maxDownloadSpeedMbpsAttribute, ok := attributes["max_download_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_download_speed_mbps is missing from object`)

		return nil, diags
	}

	maxDownloadSpeedMbpsVal, ok := maxDownloadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_download_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxDownloadSpeedMbpsAttribute))
	}

	maxUploadSpeedMbpsAttribute, ok := attributes["max_upload_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_upload_speed_mbps is missing from object`)

		return nil, diags
	}

	maxUploadSpeedMbpsVal, ok := maxUploadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_upload_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxUploadSpeedMbpsAttribute))
	}

	minPodGpuCountAttribute, ok := attributes["min_pod_gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_pod_gpu_count is missing from object`)

		return nil, diags
	}

	minPodGpuCountVal, ok := minPodGpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_pod_gpu_count expected to be basetypes.Int64Value, was: %T`, minPodGpuCountAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return nil, diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	secureCloudAttribute, ok := attributes["secure_cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_cloud is missing from object`)

		return nil, diags
	}

	secureCloudVal, ok := secureCloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_cloud expected to be basetypes.BoolValue, was: %T`, secureCloudAttribute))
	}

	supportPublicIpAttribute, ok := attributes["support_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`support_public_ip is missing from object`)

		return nil, diags
	}

	supportPublicIpVal, ok := supportPublicIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`support_public_ip expected to be basetypes.BoolValue, was: %T`, supportPublicIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MachineValue{
		CostPerHr:            costPerHrVal,
		CpuCount:             cpuCountVal,
		CpuType:              cpuTypeVal,
		CpuTypeId:            cpuTypeIdVal,
		CurrentPricePerGpu:   currentPricePerGpuVal,
		DataCenterId:         dataCenterIdVal,
		DiskThroughputMbps:   diskThroughputMbpsVal,
		GpuAvailable:         gpuAvailableVal,
		GpuDisplayName:       gpuDisplayNameVal,
		GpuType:              gpuTypeVal,
		GpuTypeId:            gpuTypeIdVal,
		Location:             locationVal,
		MaintenanceEnd:       maintenanceEndVal,
		MaintenanceNote:      maintenanceNoteVal,
		MaintenanceStart:     maintenanceStartVal,
		MaxDownloadSpeedMbps: maxDownloadSpeedMbpsVal,
		MaxUploadSpeedMbps:   maxUploadSpeedMbpsVal,
		MinPodGpuCount:       minPodGpuCountVal,
		Note:                 noteVal,
		SecureCloud:          secureCloudVal,
		SupportPublicIp:      supportPublicIpVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMachineValueNull() MachineValue {
	return MachineValue{
		state: attr.ValueStateNull,
	}
}

func NewMachineValueUnknown() MachineValue {
	return MachineValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMachineValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MachineValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MachineValue Attribute Value",
				"While creating a MachineValue value, a missing attribute value was detected. "+
					"A MachineValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MachineValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MachineValue Attribute Type",
				"While creating a MachineValue value, an invalid attribute value was detected. "+
					"A MachineValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MachineValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MachineValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MachineValue Attribute Value",
				"While creating a MachineValue value, an extra attribute value was detected. "+
					"A MachineValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MachineValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMachineValueUnknown(), diags
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	cpuCountAttribute, ok := attributes["cpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_count is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuCountVal, ok := cpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_count expected to be basetypes.Int64Value, was: %T`, cpuCountAttribute))
	}

	cpuTypeAttribute, ok := attributes["cpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuTypeVal, ok := cpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type expected to be basetypes.ObjectValue, was: %T`, cpuTypeAttribute))
	}

	cpuTypeIdAttribute, ok := attributes["cpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_type_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	cpuTypeIdVal, ok := cpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_type_id expected to be basetypes.StringValue, was: %T`, cpuTypeIdAttribute))
	}

	currentPricePerGpuAttribute, ok := attributes["current_price_per_gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_price_per_gpu is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	currentPricePerGpuVal, ok := currentPricePerGpuAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_price_per_gpu expected to be basetypes.NumberValue, was: %T`, currentPricePerGpuAttribute))
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	diskThroughputMbpsAttribute, ok := attributes["disk_throughput_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_throughput_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	diskThroughputMbpsVal, ok := diskThroughputMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_throughput_mbps expected to be basetypes.Int64Value, was: %T`, diskThroughputMbpsAttribute))
	}

	gpuAvailableAttribute, ok := attributes["gpu_available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_available is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuAvailableVal, ok := gpuAvailableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_available expected to be basetypes.Int64Value, was: %T`, gpuAvailableAttribute))
	}

	gpuDisplayNameAttribute, ok := attributes["gpu_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_display_name is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuDisplayNameVal, ok := gpuDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_display_name expected to be basetypes.StringValue, was: %T`, gpuDisplayNameAttribute))
	}

	gpuTypeAttribute, ok := attributes["gpu_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuTypeVal, ok := gpuTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type expected to be basetypes.ObjectValue, was: %T`, gpuTypeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	maintenanceEndAttribute, ok := attributes["maintenance_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_end is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceEndVal, ok := maintenanceEndAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_end expected to be basetypes.StringValue, was: %T`, maintenanceEndAttribute))
	}

	maintenanceNoteAttribute, ok := attributes["maintenance_note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_note is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceNoteVal, ok := maintenanceNoteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_note expected to be basetypes.StringValue, was: %T`, maintenanceNoteAttribute))
	}

	maintenanceStartAttribute, ok := attributes["maintenance_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance_start is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maintenanceStartVal, ok := maintenanceStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance_start expected to be basetypes.StringValue, was: %T`, maintenanceStartAttribute))
	}

	maxDownloadSpeedMbpsAttribute, ok := attributes["max_download_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_download_speed_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maxDownloadSpeedMbpsVal, ok := maxDownloadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_download_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxDownloadSpeedMbpsAttribute))
	}

	maxUploadSpeedMbpsAttribute, ok := attributes["max_upload_speed_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_upload_speed_mbps is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	maxUploadSpeedMbpsVal, ok := maxUploadSpeedMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_upload_speed_mbps expected to be basetypes.Int64Value, was: %T`, maxUploadSpeedMbpsAttribute))
	}

	minPodGpuCountAttribute, ok := attributes["min_pod_gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_pod_gpu_count is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	minPodGpuCountVal, ok := minPodGpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_pod_gpu_count expected to be basetypes.Int64Value, was: %T`, minPodGpuCountAttribute))
	}

	noteAttribute, ok := attributes["note"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`note is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	noteVal, ok := noteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`note expected to be basetypes.StringValue, was: %T`, noteAttribute))
	}

	secureCloudAttribute, ok := attributes["secure_cloud"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_cloud is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	secureCloudVal, ok := secureCloudAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_cloud expected to be basetypes.BoolValue, was: %T`, secureCloudAttribute))
	}

	supportPublicIpAttribute, ok := attributes["support_public_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`support_public_ip is missing from object`)

		return NewMachineValueUnknown(), diags
	}

	supportPublicIpVal, ok := supportPublicIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`support_public_ip expected to be basetypes.BoolValue, was: %T`, supportPublicIpAttribute))
	}

	if diags.HasError() {
		return NewMachineValueUnknown(), diags
	}

	return MachineValue{
		CostPerHr:            costPerHrVal,
		CpuCount:             cpuCountVal,
		CpuType:              cpuTypeVal,
		CpuTypeId:            cpuTypeIdVal,
		CurrentPricePerGpu:   currentPricePerGpuVal,
		DataCenterId:         dataCenterIdVal,
		DiskThroughputMbps:   diskThroughputMbpsVal,
		GpuAvailable:         gpuAvailableVal,
		GpuDisplayName:       gpuDisplayNameVal,
		GpuType:              gpuTypeVal,
		GpuTypeId:            gpuTypeIdVal,
		Location:             locationVal,
		MaintenanceEnd:       maintenanceEndVal,
		MaintenanceNote:      maintenanceNoteVal,
		MaintenanceStart:     maintenanceStartVal,
		MaxDownloadSpeedMbps: maxDownloadSpeedMbpsVal,
		MaxUploadSpeedMbps:   maxUploadSpeedMbpsVal,
		MinPodGpuCount:       minPodGpuCountVal,
		Note:                 noteVal,
		SecureCloud:          secureCloudVal,
		SupportPublicIp:      supportPublicIpVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMachineValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MachineValue {
	object, diags := NewMachineValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMachineValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MachineType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMachineValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMachineValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMachineValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMachineValueMust(MachineValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MachineType) ValueType(ctx context.Context) attr.Value {
	return MachineValue{}
}

var _ basetypes.ObjectValuable = MachineValue{}

type MachineValue struct {
	CostPerHr            basetypes.NumberValue `tfsdk:"cost_per_hr"`
	CpuCount             basetypes.Int64Value  `tfsdk:"cpu_count"`
	CpuType              basetypes.ObjectValue `tfsdk:"cpu_type"`
	CpuTypeId            basetypes.StringValue `tfsdk:"cpu_type_id"`
	CurrentPricePerGpu   basetypes.NumberValue `tfsdk:"current_price_per_gpu"`
	DataCenterId         basetypes.StringValue `tfsdk:"data_center_id"`
	DiskThroughputMbps   basetypes.Int64Value  `tfsdk:"disk_throughput_mbps"`
	GpuAvailable         basetypes.Int64Value  `tfsdk:"gpu_available"`
	GpuDisplayName       basetypes.StringValue `tfsdk:"gpu_display_name"`
	GpuType              basetypes.ObjectValue `tfsdk:"gpu_type"`
	GpuTypeId            basetypes.StringValue `tfsdk:"gpu_type_id"`
	Location             basetypes.StringValue `tfsdk:"location"`
	MaintenanceEnd       basetypes.StringValue `tfsdk:"maintenance_end"`
	MaintenanceNote      basetypes.StringValue `tfsdk:"maintenance_note"`
	MaintenanceStart     basetypes.StringValue `tfsdk:"maintenance_start"`
	MaxDownloadSpeedMbps basetypes.Int64Value  `tfsdk:"max_download_speed_mbps"`
	MaxUploadSpeedMbps   basetypes.Int64Value  `tfsdk:"max_upload_speed_mbps"`
	MinPodGpuCount       basetypes.Int64Value  `tfsdk:"min_pod_gpu_count"`
	Note                 basetypes.StringValue `tfsdk:"note"`
	SecureCloud          basetypes.BoolValue   `tfsdk:"secure_cloud"`
	SupportPublicIp      basetypes.BoolValue   `tfsdk:"support_public_ip"`
	state                attr.ValueState
}

func (v MachineValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["cpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cpu_type"] = basetypes.ObjectType{
		AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["current_price_per_gpu"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["data_center_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk_throughput_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_available"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_type"] = basetypes.ObjectType{
		AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_note"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["maintenance_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_download_speed_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_upload_speed_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_pod_gpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["note"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secure_cloud"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["support_public_ip"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.CostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost_per_hr"] = val

		val, err = v.CpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_count"] = val

		val, err = v.CpuType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_type"] = val

		val, err = v.CpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_type_id"] = val

		val, err = v.CurrentPricePerGpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_price_per_gpu"] = val

		val, err = v.DataCenterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_center_id"] = val

		val, err = v.DiskThroughputMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_throughput_mbps"] = val

		val, err = v.GpuAvailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_available"] = val

		val, err = v.GpuDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_display_name"] = val

		val, err = v.GpuType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type"] = val

		val, err = v.GpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type_id"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.MaintenanceEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_end"] = val

		val, err = v.MaintenanceNote.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_note"] = val

		val, err = v.MaintenanceStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance_start"] = val

		val, err = v.MaxDownloadSpeedMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_download_speed_mbps"] = val

		val, err = v.MaxUploadSpeedMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_upload_speed_mbps"] = val

		val, err = v.MinPodGpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_pod_gpu_count"] = val

		val, err = v.Note.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["note"] = val

		val, err = v.SecureCloud.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_cloud"] = val

		val, err = v.SupportPublicIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["support_public_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MachineValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MachineValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MachineValue) String() string {
	return "MachineValue"
}

func (v MachineValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cpuType basetypes.ObjectValue

	if v.CpuType.IsNull() {
		cpuType = types.ObjectNull(
			CpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.CpuType.IsUnknown() {
		cpuType = types.ObjectUnknown(
			CpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CpuType.IsNull() && !v.CpuType.IsUnknown() {
		cpuType = types.ObjectValueMust(
			CpuTypeValue{}.AttributeTypes(ctx),
			v.CpuType.Attributes(),
		)
	}

	var gpuType basetypes.ObjectValue

	if v.GpuType.IsNull() {
		gpuType = types.ObjectNull(
			GpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.GpuType.IsUnknown() {
		gpuType = types.ObjectUnknown(
			GpuTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.GpuType.IsNull() && !v.GpuType.IsUnknown() {
		gpuType = types.ObjectValueMust(
			GpuTypeValue{}.AttributeTypes(ctx),
			v.GpuType.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"cpu_count":   basetypes.Int64Type{},
		"cpu_type": basetypes.ObjectType{
			AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
		},
		"cpu_type_id":           basetypes.StringType{},
		"current_price_per_gpu": basetypes.NumberType{},
		"data_center_id":        basetypes.StringType{},
		"disk_throughput_mbps":  basetypes.Int64Type{},
		"gpu_available":         basetypes.Int64Type{},
		"gpu_display_name":      basetypes.StringType{},
		"gpu_type": basetypes.ObjectType{
			AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
		},
		"gpu_type_id":             basetypes.StringType{},
		"location":                basetypes.StringType{},
		"maintenance_end":         basetypes.StringType{},
		"maintenance_note":        basetypes.StringType{},
		"maintenance_start":       basetypes.StringType{},
		"max_download_speed_mbps": basetypes.Int64Type{},
		"max_upload_speed_mbps":   basetypes.Int64Type{},
		"min_pod_gpu_count":       basetypes.Int64Type{},
		"note":                    basetypes.StringType{},
		"secure_cloud":            basetypes.BoolType{},
		"support_public_ip":       basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost_per_hr":             v.CostPerHr,
			"cpu_count":               v.CpuCount,
			"cpu_type":                cpuType,
			"cpu_type_id":             v.CpuTypeId,
			"current_price_per_gpu":   v.CurrentPricePerGpu,
			"data_center_id":          v.DataCenterId,
			"disk_throughput_mbps":    v.DiskThroughputMbps,
			"gpu_available":           v.GpuAvailable,
			"gpu_display_name":        v.GpuDisplayName,
			"gpu_type":                gpuType,
			"gpu_type_id":             v.GpuTypeId,
			"location":                v.Location,
			"maintenance_end":         v.MaintenanceEnd,
			"maintenance_note":        v.MaintenanceNote,
			"maintenance_start":       v.MaintenanceStart,
			"max_download_speed_mbps": v.MaxDownloadSpeedMbps,
			"max_upload_speed_mbps":   v.MaxUploadSpeedMbps,
			"min_pod_gpu_count":       v.MinPodGpuCount,
			"note":                    v.Note,
			"secure_cloud":            v.SecureCloud,
			"support_public_ip":       v.SupportPublicIp,
		})

	return objVal, diags
}

func (v MachineValue) Equal(o attr.Value) bool {
	other, ok := o.(MachineValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CostPerHr.Equal(other.CostPerHr) {
		return false
	}

	if !v.CpuCount.Equal(other.CpuCount) {
		return false
	}

	if !v.CpuType.Equal(other.CpuType) {
		return false
	}

	if !v.CpuTypeId.Equal(other.CpuTypeId) {
		return false
	}

	if !v.CurrentPricePerGpu.Equal(other.CurrentPricePerGpu) {
		return false
	}

	if !v.DataCenterId.Equal(other.DataCenterId) {
		return false
	}

	if !v.DiskThroughputMbps.Equal(other.DiskThroughputMbps) {
		return false
	}

	if !v.GpuAvailable.Equal(other.GpuAvailable) {
		return false
	}

	if !v.GpuDisplayName.Equal(other.GpuDisplayName) {
		return false
	}

	if !v.GpuType.Equal(other.GpuType) {
		return false
	}

	if !v.GpuTypeId.Equal(other.GpuTypeId) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.MaintenanceEnd.Equal(other.MaintenanceEnd) {
		return false
	}

	if !v.MaintenanceNote.Equal(other.MaintenanceNote) {
		return false
	}

	if !v.MaintenanceStart.Equal(other.MaintenanceStart) {
		return false
	}

	if !v.MaxDownloadSpeedMbps.Equal(other.MaxDownloadSpeedMbps) {
		return false
	}

	if !v.MaxUploadSpeedMbps.Equal(other.MaxUploadSpeedMbps) {
		return false
	}

	if !v.MinPodGpuCount.Equal(other.MinPodGpuCount) {
		return false
	}

	if !v.Note.Equal(other.Note) {
		return false
	}

	if !v.SecureCloud.Equal(other.SecureCloud) {
		return false
	}

	if !v.SupportPublicIp.Equal(other.SupportPublicIp) {
		return false
	}

	return true
}

func (v MachineValue) Type(ctx context.Context) attr.Type {
	return MachineType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MachineValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"cpu_count":   basetypes.Int64Type{},
		"cpu_type": basetypes.ObjectType{
			AttrTypes: CpuTypeValue{}.AttributeTypes(ctx),
		},
		"cpu_type_id":           basetypes.StringType{},
		"current_price_per_gpu": basetypes.NumberType{},
		"data_center_id":        basetypes.StringType{},
		"disk_throughput_mbps":  basetypes.Int64Type{},
		"gpu_available":         basetypes.Int64Type{},
		"gpu_display_name":      basetypes.StringType{},
		"gpu_type": basetypes.ObjectType{
			AttrTypes: GpuTypeValue{}.AttributeTypes(ctx),
		},
		"gpu_type_id":             basetypes.StringType{},
		"location":                basetypes.StringType{},
		"maintenance_end":         basetypes.StringType{},
		"maintenance_note":        basetypes.StringType{},
		"maintenance_start":       basetypes.StringType{},
		"max_download_speed_mbps": basetypes.Int64Type{},
		"max_upload_speed_mbps":   basetypes.Int64Type{},
		"min_pod_gpu_count":       basetypes.Int64Type{},
		"note":                    basetypes.StringType{},
		"secure_cloud":            basetypes.BoolType{},
		"support_public_ip":       basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CpuTypeType{}

type CpuTypeType struct {
	basetypes.ObjectType
}

func (t CpuTypeType) Equal(o attr.Type) bool {
	other, ok := o.(CpuTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuTypeType) String() string {
	return "CpuTypeType"
}

func (t CpuTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	coresAttribute, ok := attributes["cores"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cores is missing from object`)

		return nil, diags
	}

	coresVal, ok := coresAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cores expected to be basetypes.NumberValue, was: %T`, coresAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return nil, diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	threadsPerCoreAttribute, ok := attributes["threads_per_core"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threads_per_core is missing from object`)

		return nil, diags
	}

	threadsPerCoreVal, ok := threadsPerCoreAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threads_per_core expected to be basetypes.NumberValue, was: %T`, threadsPerCoreAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuTypeValue{
		Cores:          coresVal,
		DisplayName:    displayNameVal,
		GroupId:        groupIdVal,
		Id:             idVal,
		ThreadsPerCore: threadsPerCoreVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCpuTypeValueNull() CpuTypeValue {
	return CpuTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuTypeValueUnknown() CpuTypeValue {
	return CpuTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuTypeValue Attribute Value",
				"While creating a CpuTypeValue value, a missing attribute value was detected. "+
					"A CpuTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuTypeValue Attribute Type",
				"While creating a CpuTypeValue value, an invalid attribute value was detected. "+
					"A CpuTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuTypeValue Attribute Value",
				"While creating a CpuTypeValue value, an extra attribute value was detected. "+
					"A CpuTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuTypeValueUnknown(), diags
	}

	coresAttribute, ok := attributes["cores"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cores is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	coresVal, ok := coresAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cores expected to be basetypes.NumberValue, was: %T`, coresAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	groupIdAttribute, ok := attributes["group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_id is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	groupIdVal, ok := groupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_id expected to be basetypes.StringValue, was: %T`, groupIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	threadsPerCoreAttribute, ok := attributes["threads_per_core"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threads_per_core is missing from object`)

		return NewCpuTypeValueUnknown(), diags
	}

	threadsPerCoreVal, ok := threadsPerCoreAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threads_per_core expected to be basetypes.NumberValue, was: %T`, threadsPerCoreAttribute))
	}

	if diags.HasError() {
		return NewCpuTypeValueUnknown(), diags
	}

	return CpuTypeValue{
		Cores:          coresVal,
		DisplayName:    displayNameVal,
		GroupId:        groupIdVal,
		Id:             idVal,
		ThreadsPerCore: threadsPerCoreVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCpuTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuTypeValue {
	object, diags := NewCpuTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuTypeValueMust(CpuTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuTypeType) ValueType(ctx context.Context) attr.Value {
	return CpuTypeValue{}
}

var _ basetypes.ObjectValuable = CpuTypeValue{}

type CpuTypeValue struct {
	Cores          basetypes.NumberValue `tfsdk:"cores"`
	DisplayName    basetypes.StringValue `tfsdk:"display_name"`
	GroupId        basetypes.StringValue `tfsdk:"group_id"`
	Id             basetypes.StringValue `tfsdk:"id"`
	ThreadsPerCore basetypes.NumberValue `tfsdk:"threads_per_core"`
	state          attr.ValueState
}

func (v CpuTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cores"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["group_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["threads_per_core"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Cores.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cores"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.GroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ThreadsPerCore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threads_per_core"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuTypeValue) String() string {
	return "CpuTypeValue"
}

func (v CpuTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cores":            basetypes.NumberType{},
		"display_name":     basetypes.StringType{},
		"group_id":         basetypes.StringType{},
		"id":               basetypes.StringType{},
		"threads_per_core": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cores":            v.Cores,
			"display_name":     v.DisplayName,
			"group_id":         v.GroupId,
			"id":               v.Id,
			"threads_per_core": v.ThreadsPerCore,
		})

	return objVal, diags
}

func (v CpuTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cores.Equal(other.Cores) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.GroupId.Equal(other.GroupId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ThreadsPerCore.Equal(other.ThreadsPerCore) {
		return false
	}

	return true
}

func (v CpuTypeValue) Type(ctx context.Context) attr.Type {
	return CpuTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cores":            basetypes.NumberType{},
		"display_name":     basetypes.StringType{},
		"group_id":         basetypes.StringType{},
		"id":               basetypes.StringType{},
		"threads_per_core": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = GpuTypeType{}

type GpuTypeType struct {
	basetypes.ObjectType
}

func (t GpuTypeType) Equal(o attr.Type) bool {
	other, ok := o.(GpuTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GpuTypeType) String() string {
	return "GpuTypeType"
}

func (t GpuTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return nil, diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return nil, diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return nil, diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return nil, diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return nil, diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return nil, diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return nil, diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return nil, diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GpuTypeValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuTypeValueNull() GpuTypeValue {
	return GpuTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewGpuTypeValueUnknown() GpuTypeValue {
	return GpuTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGpuTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GpuTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GpuTypeValue Attribute Value",
				"While creating a GpuTypeValue value, a missing attribute value was detected. "+
					"A GpuTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GpuTypeValue Attribute Type",
				"While creating a GpuTypeValue value, an invalid attribute value was detected. "+
					"A GpuTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GpuTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GpuTypeValue Attribute Value",
				"While creating a GpuTypeValue value, an extra attribute value was detected. "+
					"A GpuTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GpuTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGpuTypeValueUnknown(), diags
	}

	communityPriceAttribute, ok := attributes["community_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	communityPriceVal, ok := communityPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_price expected to be basetypes.NumberValue, was: %T`, communityPriceAttribute))
	}

	communitySpotPriceAttribute, ok := attributes["community_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_spot_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	communitySpotPriceVal, ok := communitySpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_spot_price expected to be basetypes.NumberValue, was: %T`, communitySpotPriceAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	oneMonthPriceAttribute, ok := attributes["one_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	oneMonthPriceVal, ok := oneMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_month_price expected to be basetypes.NumberValue, was: %T`, oneMonthPriceAttribute))
	}

	oneWeekPriceAttribute, ok := attributes["one_week_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`one_week_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	oneWeekPriceVal, ok := oneWeekPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`one_week_price expected to be basetypes.NumberValue, was: %T`, oneWeekPriceAttribute))
	}

	securePriceAttribute, ok := attributes["secure_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	securePriceVal, ok := securePriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_price expected to be basetypes.NumberValue, was: %T`, securePriceAttribute))
	}

	secureSpotPriceAttribute, ok := attributes["secure_spot_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_spot_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	secureSpotPriceVal, ok := secureSpotPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_spot_price expected to be basetypes.NumberValue, was: %T`, secureSpotPriceAttribute))
	}

	sixMonthPriceAttribute, ok := attributes["six_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`six_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	sixMonthPriceVal, ok := sixMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`six_month_price expected to be basetypes.NumberValue, was: %T`, sixMonthPriceAttribute))
	}

	threeMonthPriceAttribute, ok := attributes["three_month_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`three_month_price is missing from object`)

		return NewGpuTypeValueUnknown(), diags
	}

	threeMonthPriceVal, ok := threeMonthPriceAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`three_month_price expected to be basetypes.NumberValue, was: %T`, threeMonthPriceAttribute))
	}

	if diags.HasError() {
		return NewGpuTypeValueUnknown(), diags
	}

	return GpuTypeValue{
		CommunityPrice:     communityPriceVal,
		CommunitySpotPrice: communitySpotPriceVal,
		Count:              countVal,
		DisplayName:        displayNameVal,
		Id:                 idVal,
		OneMonthPrice:      oneMonthPriceVal,
		OneWeekPrice:       oneWeekPriceVal,
		SecurePrice:        securePriceVal,
		SecureSpotPrice:    secureSpotPriceVal,
		SixMonthPrice:      sixMonthPriceVal,
		ThreeMonthPrice:    threeMonthPriceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewGpuTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GpuTypeValue {
	object, diags := NewGpuTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGpuTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GpuTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGpuTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGpuTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGpuTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGpuTypeValueMust(GpuTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GpuTypeType) ValueType(ctx context.Context) attr.Value {
	return GpuTypeValue{}
}

var _ basetypes.ObjectValuable = GpuTypeValue{}

type GpuTypeValue struct {
	CommunityPrice     basetypes.NumberValue `tfsdk:"community_price"`
	CommunitySpotPrice basetypes.NumberValue `tfsdk:"community_spot_price"`
	Count              basetypes.Int64Value  `tfsdk:"count"`
	DisplayName        basetypes.StringValue `tfsdk:"display_name"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	OneMonthPrice      basetypes.NumberValue `tfsdk:"one_month_price"`
	OneWeekPrice       basetypes.NumberValue `tfsdk:"one_week_price"`
	SecurePrice        basetypes.NumberValue `tfsdk:"secure_price"`
	SecureSpotPrice    basetypes.NumberValue `tfsdk:"secure_spot_price"`
	SixMonthPrice      basetypes.NumberValue `tfsdk:"six_month_price"`
	ThreeMonthPrice    basetypes.NumberValue `tfsdk:"three_month_price"`
	state              attr.ValueState
}

func (v GpuTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["community_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["community_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["one_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["one_week_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["secure_spot_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["six_month_price"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["three_month_price"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CommunityPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_price"] = val

		val, err = v.CommunitySpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_spot_price"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.OneMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_month_price"] = val

		val, err = v.OneWeekPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["one_week_price"] = val

		val, err = v.SecurePrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_price"] = val

		val, err = v.SecureSpotPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_spot_price"] = val

		val, err = v.SixMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["six_month_price"] = val

		val, err = v.ThreeMonthPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["three_month_price"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GpuTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GpuTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GpuTypeValue) String() string {
	return "GpuTypeValue"
}

func (v GpuTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"community_price":      v.CommunityPrice,
			"community_spot_price": v.CommunitySpotPrice,
			"count":                v.Count,
			"display_name":         v.DisplayName,
			"id":                   v.Id,
			"one_month_price":      v.OneMonthPrice,
			"one_week_price":       v.OneWeekPrice,
			"secure_price":         v.SecurePrice,
			"secure_spot_price":    v.SecureSpotPrice,
			"six_month_price":      v.SixMonthPrice,
			"three_month_price":    v.ThreeMonthPrice,
		})

	return objVal, diags
}

func (v GpuTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(GpuTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommunityPrice.Equal(other.CommunityPrice) {
		return false
	}

	if !v.CommunitySpotPrice.Equal(other.CommunitySpotPrice) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.OneMonthPrice.Equal(other.OneMonthPrice) {
		return false
	}

	if !v.OneWeekPrice.Equal(other.OneWeekPrice) {
		return false
	}

	if !v.SecurePrice.Equal(other.SecurePrice) {
		return false
	}

	if !v.SecureSpotPrice.Equal(other.SecureSpotPrice) {
		return false
	}

	if !v.SixMonthPrice.Equal(other.SixMonthPrice) {
		return false
	}

	if !v.ThreeMonthPrice.Equal(other.ThreeMonthPrice) {
		return false
	}

	return true
}

func (v GpuTypeValue) Type(ctx context.Context) attr.Type {
	return GpuTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GpuTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"community_price":      basetypes.NumberType{},
		"community_spot_price": basetypes.NumberType{},
		"count":                basetypes.Int64Type{},
		"display_name":         basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"one_month_price":      basetypes.NumberType{},
		"one_week_price":       basetypes.NumberType{},
		"secure_price":         basetypes.NumberType{},
		"secure_spot_price":    basetypes.NumberType{},
		"six_month_price":      basetypes.NumberType{},
		"three_month_price":    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = NetworkVolumeType{}

type NetworkVolumeType struct {
	basetypes.ObjectType
}

func (t NetworkVolumeType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkVolumeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkVolumeType) String() string {
	return "NetworkVolumeType"
}

func (t NetworkVolumeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return nil, diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkVolumeValue{
		DataCenterId: dataCenterIdVal,
		Id:           idVal,
		Name:         nameVal,
		Size:         sizeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetworkVolumeValueNull() NetworkVolumeValue {
	return NetworkVolumeValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkVolumeValueUnknown() NetworkVolumeValue {
	return NetworkVolumeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkVolumeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkVolumeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkVolumeValue Attribute Value",
				"While creating a NetworkVolumeValue value, a missing attribute value was detected. "+
					"A NetworkVolumeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkVolumeValue Attribute Type",
				"While creating a NetworkVolumeValue value, an invalid attribute value was detected. "+
					"A NetworkVolumeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkVolumeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkVolumeValue Attribute Value",
				"While creating a NetworkVolumeValue value, an extra attribute value was detected. "+
					"A NetworkVolumeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkVolumeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkVolumeValueUnknown(), diags
	}

	dataCenterIdAttribute, ok := attributes["data_center_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_center_id is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	dataCenterIdVal, ok := dataCenterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_center_id expected to be basetypes.StringValue, was: %T`, dataCenterIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewNetworkVolumeValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewNetworkVolumeValueUnknown(), diags
	}

	return NetworkVolumeValue{
		DataCenterId: dataCenterIdVal,
		Id:           idVal,
		Name:         nameVal,
		Size:         sizeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNetworkVolumeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkVolumeValue {
	object, diags := NewNetworkVolumeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkVolumeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkVolumeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkVolumeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkVolumeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkVolumeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkVolumeValueMust(NetworkVolumeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkVolumeType) ValueType(ctx context.Context) attr.Value {
	return NetworkVolumeValue{}
}

var _ basetypes.ObjectValuable = NetworkVolumeValue{}

type NetworkVolumeValue struct {
	DataCenterId basetypes.StringValue `tfsdk:"data_center_id"`
	Id           basetypes.StringValue `tfsdk:"id"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Size         basetypes.Int64Value  `tfsdk:"size"`
	state        attr.ValueState
}

func (v NetworkVolumeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["data_center_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DataCenterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_center_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkVolumeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkVolumeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkVolumeValue) String() string {
	return "NetworkVolumeValue"
}

func (v NetworkVolumeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"data_center_id": basetypes.StringType{},
		"id":             basetypes.StringType{},
		"name":           basetypes.StringType{},
		"size":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data_center_id": v.DataCenterId,
			"id":             v.Id,
			"name":           v.Name,
			"size":           v.Size,
		})

	return objVal, diags
}

func (v NetworkVolumeValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkVolumeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataCenterId.Equal(other.DataCenterId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v NetworkVolumeValue) Type(ctx context.Context) attr.Type {
	return NetworkVolumeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkVolumeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_center_id": basetypes.StringType{},
		"id":             basetypes.StringType{},
		"name":           basetypes.StringType{},
		"size":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortMappingsType{}

type PortMappingsType struct {
	basetypes.ObjectType
}

func (t PortMappingsType) Equal(o attr.Type) bool {
	other, ok := o.(PortMappingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMappingsType) String() string {
	return "PortMappingsType"
}

func (t PortMappingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return PortMappingsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewPortMappingsValueNull() PortMappingsValue {
	return PortMappingsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMappingsValueUnknown() PortMappingsValue {
	return PortMappingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMappingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMappingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMappingsValue Attribute Value",
				"While creating a PortMappingsValue value, a missing attribute value was detected. "+
					"A PortMappingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMappingsValue Attribute Type",
				"While creating a PortMappingsValue value, an invalid attribute value was detected. "+
					"A PortMappingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMappingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMappingsValue Attribute Value",
				"While creating a PortMappingsValue value, an extra attribute value was detected. "+
					"A PortMappingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMappingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMappingsValueUnknown(), diags
	}

	if diags.HasError() {
		return NewPortMappingsValueUnknown(), diags
	}

	return PortMappingsValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewPortMappingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMappingsValue {
	object, diags := NewPortMappingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMappingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMappingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMappingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMappingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMappingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMappingsValueMust(PortMappingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMappingsType) ValueType(ctx context.Context) attr.Value {
	return PortMappingsValue{}
}

var _ basetypes.ObjectValuable = PortMappingsValue{}

type PortMappingsValue struct {
	state attr.ValueState
}

func (v PortMappingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMappingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMappingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMappingsValue) String() string {
	return "PortMappingsValue"
}

func (v PortMappingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v PortMappingsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMappingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v PortMappingsValue) Type(ctx context.Context) attr.Type {
	return PortMappingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMappingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}

var _ basetypes.ObjectTypable = SavingsPlansType{}

type SavingsPlansType struct {
	basetypes.ObjectType
}

func (t SavingsPlansType) Equal(o attr.Type) bool {
	other, ok := o.(SavingsPlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SavingsPlansType) String() string {
	return "SavingsPlansType"
}

func (t SavingsPlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return nil, diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	endTimeAttribute, ok := attributes["end_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_time is missing from object`)

		return nil, diags
	}

	endTimeVal, ok := endTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_time expected to be basetypes.StringValue, was: %T`, endTimeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return nil, diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	podIdAttribute, ok := attributes["pod_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_id is missing from object`)

		return nil, diags
	}

	podIdVal, ok := podIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_id expected to be basetypes.StringValue, was: %T`, podIdAttribute))
	}

	startTimeAttribute, ok := attributes["start_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_time is missing from object`)

		return nil, diags
	}

	startTimeVal, ok := startTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_time expected to be basetypes.StringValue, was: %T`, startTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SavingsPlansValue{
		CostPerHr: costPerHrVal,
		EndTime:   endTimeVal,
		GpuTypeId: gpuTypeIdVal,
		Id:        idVal,
		PodId:     podIdVal,
		StartTime: startTimeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSavingsPlansValueNull() SavingsPlansValue {
	return SavingsPlansValue{
		state: attr.ValueStateNull,
	}
}

func NewSavingsPlansValueUnknown() SavingsPlansValue {
	return SavingsPlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSavingsPlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SavingsPlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SavingsPlansValue Attribute Value",
				"While creating a SavingsPlansValue value, a missing attribute value was detected. "+
					"A SavingsPlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SavingsPlansValue Attribute Type",
				"While creating a SavingsPlansValue value, an invalid attribute value was detected. "+
					"A SavingsPlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SavingsPlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SavingsPlansValue Attribute Value",
				"While creating a SavingsPlansValue value, an extra attribute value was detected. "+
					"A SavingsPlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SavingsPlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSavingsPlansValueUnknown(), diags
	}

	costPerHrAttribute, ok := attributes["cost_per_hr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost_per_hr is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	costPerHrVal, ok := costPerHrAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost_per_hr expected to be basetypes.NumberValue, was: %T`, costPerHrAttribute))
	}

	endTimeAttribute, ok := attributes["end_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_time is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	endTimeVal, ok := endTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_time expected to be basetypes.StringValue, was: %T`, endTimeAttribute))
	}

	gpuTypeIdAttribute, ok := attributes["gpu_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_type_id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	gpuTypeIdVal, ok := gpuTypeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_type_id expected to be basetypes.StringValue, was: %T`, gpuTypeIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	podIdAttribute, ok := attributes["pod_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_id is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	podIdVal, ok := podIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_id expected to be basetypes.StringValue, was: %T`, podIdAttribute))
	}

	startTimeAttribute, ok := attributes["start_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_time is missing from object`)

		return NewSavingsPlansValueUnknown(), diags
	}

	startTimeVal, ok := startTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_time expected to be basetypes.StringValue, was: %T`, startTimeAttribute))
	}

	if diags.HasError() {
		return NewSavingsPlansValueUnknown(), diags
	}

	return SavingsPlansValue{
		CostPerHr: costPerHrVal,
		EndTime:   endTimeVal,
		GpuTypeId: gpuTypeIdVal,
		Id:        idVal,
		PodId:     podIdVal,
		StartTime: startTimeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSavingsPlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SavingsPlansValue {
	object, diags := NewSavingsPlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSavingsPlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SavingsPlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSavingsPlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSavingsPlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSavingsPlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSavingsPlansValueMust(SavingsPlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SavingsPlansType) ValueType(ctx context.Context) attr.Value {
	return SavingsPlansValue{}
}

var _ basetypes.ObjectValuable = SavingsPlansValue{}

type SavingsPlansValue struct {
	CostPerHr basetypes.NumberValue `tfsdk:"cost_per_hr"`
	EndTime   basetypes.StringValue `tfsdk:"end_time"`
	GpuTypeId basetypes.StringValue `tfsdk:"gpu_type_id"`
	Id        basetypes.StringValue `tfsdk:"id"`
	PodId     basetypes.StringValue `tfsdk:"pod_id"`
	StartTime basetypes.StringValue `tfsdk:"start_time"`
	state     attr.ValueState
}

func (v SavingsPlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["cost_per_hr"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["end_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_type_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.CostPerHr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost_per_hr"] = val

		val, err = v.EndTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end_time"] = val

		val, err = v.GpuTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_type_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.PodId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_id"] = val

		val, err = v.StartTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SavingsPlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SavingsPlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SavingsPlansValue) String() string {
	return "SavingsPlansValue"
}

func (v SavingsPlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"end_time":    basetypes.StringType{},
		"gpu_type_id": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"pod_id":      basetypes.StringType{},
		"start_time":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost_per_hr": v.CostPerHr,
			"end_time":    v.EndTime,
			"gpu_type_id": v.GpuTypeId,
			"id":          v.Id,
			"pod_id":      v.PodId,
			"start_time":  v.StartTime,
		})

	return objVal, diags
}

func (v SavingsPlansValue) Equal(o attr.Value) bool {
	other, ok := o.(SavingsPlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CostPerHr.Equal(other.CostPerHr) {
		return false
	}

	if !v.EndTime.Equal(other.EndTime) {
		return false
	}

	if !v.GpuTypeId.Equal(other.GpuTypeId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.PodId.Equal(other.PodId) {
		return false
	}

	if !v.StartTime.Equal(other.StartTime) {
		return false
	}

	return true
}

func (v SavingsPlansValue) Type(ctx context.Context) attr.Type {
	return SavingsPlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SavingsPlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost_per_hr": basetypes.NumberType{},
		"end_time":    basetypes.StringType{},
		"gpu_type_id": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"pod_id":      basetypes.StringType{},
		"start_time":  basetypes.StringType{},
	}
}
